// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: envoy/config/core/v3/base.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_envoy_2fconfig_2fcore_2fv3_2fbase_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_envoy_2fconfig_2fcore_2fv3_2fbase_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3009000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3009001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "envoy/config/core/v3/address.pb.h"
#include "envoy/config/core/v3/backoff.pb.h"
#include "envoy/config/core/v3/http_uri.pb.h"
#include "envoy/type/v3/percent.pb.h"
#include "envoy/type/v3/semantic_version.pb.h"
#include <google/protobuf/any.pb.h>
#include <google/protobuf/duration.pb.h>
#include <google/protobuf/struct.pb.h>
#include <google/protobuf/wrappers.pb.h>
#include "udpa/annotations/status.pb.h"
#include "udpa/annotations/versioning.pb.h"
#include "validate/validate.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_envoy_2fconfig_2fcore_2fv3_2fbase_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_envoy_2fconfig_2fcore_2fv3_2fbase_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[18]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_envoy_2fconfig_2fcore_2fv3_2fbase_2eproto;
namespace envoy {
namespace config {
namespace core {
namespace v3 {
class AsyncDataSource;
class AsyncDataSourceDefaultTypeInternal;
extern AsyncDataSourceDefaultTypeInternal _AsyncDataSource_default_instance_;
class BuildVersion;
class BuildVersionDefaultTypeInternal;
extern BuildVersionDefaultTypeInternal _BuildVersion_default_instance_;
class ControlPlane;
class ControlPlaneDefaultTypeInternal;
extern ControlPlaneDefaultTypeInternal _ControlPlane_default_instance_;
class DataSource;
class DataSourceDefaultTypeInternal;
extern DataSourceDefaultTypeInternal _DataSource_default_instance_;
class Extension;
class ExtensionDefaultTypeInternal;
extern ExtensionDefaultTypeInternal _Extension_default_instance_;
class HeaderMap;
class HeaderMapDefaultTypeInternal;
extern HeaderMapDefaultTypeInternal _HeaderMap_default_instance_;
class HeaderValue;
class HeaderValueDefaultTypeInternal;
extern HeaderValueDefaultTypeInternal _HeaderValue_default_instance_;
class HeaderValueOption;
class HeaderValueOptionDefaultTypeInternal;
extern HeaderValueOptionDefaultTypeInternal _HeaderValueOption_default_instance_;
class Locality;
class LocalityDefaultTypeInternal;
extern LocalityDefaultTypeInternal _Locality_default_instance_;
class Metadata;
class MetadataDefaultTypeInternal;
extern MetadataDefaultTypeInternal _Metadata_default_instance_;
class Metadata_FilterMetadataEntry_DoNotUse;
class Metadata_FilterMetadataEntry_DoNotUseDefaultTypeInternal;
extern Metadata_FilterMetadataEntry_DoNotUseDefaultTypeInternal _Metadata_FilterMetadataEntry_DoNotUse_default_instance_;
class Node;
class NodeDefaultTypeInternal;
extern NodeDefaultTypeInternal _Node_default_instance_;
class RemoteDataSource;
class RemoteDataSourceDefaultTypeInternal;
extern RemoteDataSourceDefaultTypeInternal _RemoteDataSource_default_instance_;
class RetryPolicy;
class RetryPolicyDefaultTypeInternal;
extern RetryPolicyDefaultTypeInternal _RetryPolicy_default_instance_;
class RuntimeFeatureFlag;
class RuntimeFeatureFlagDefaultTypeInternal;
extern RuntimeFeatureFlagDefaultTypeInternal _RuntimeFeatureFlag_default_instance_;
class RuntimeFractionalPercent;
class RuntimeFractionalPercentDefaultTypeInternal;
extern RuntimeFractionalPercentDefaultTypeInternal _RuntimeFractionalPercent_default_instance_;
class RuntimeUInt32;
class RuntimeUInt32DefaultTypeInternal;
extern RuntimeUInt32DefaultTypeInternal _RuntimeUInt32_default_instance_;
class TransportSocket;
class TransportSocketDefaultTypeInternal;
extern TransportSocketDefaultTypeInternal _TransportSocket_default_instance_;
}  // namespace v3
}  // namespace core
}  // namespace config
}  // namespace envoy
PROTOBUF_NAMESPACE_OPEN
template<> ::envoy::config::core::v3::AsyncDataSource* Arena::CreateMaybeMessage<::envoy::config::core::v3::AsyncDataSource>(Arena*);
template<> ::envoy::config::core::v3::BuildVersion* Arena::CreateMaybeMessage<::envoy::config::core::v3::BuildVersion>(Arena*);
template<> ::envoy::config::core::v3::ControlPlane* Arena::CreateMaybeMessage<::envoy::config::core::v3::ControlPlane>(Arena*);
template<> ::envoy::config::core::v3::DataSource* Arena::CreateMaybeMessage<::envoy::config::core::v3::DataSource>(Arena*);
template<> ::envoy::config::core::v3::Extension* Arena::CreateMaybeMessage<::envoy::config::core::v3::Extension>(Arena*);
template<> ::envoy::config::core::v3::HeaderMap* Arena::CreateMaybeMessage<::envoy::config::core::v3::HeaderMap>(Arena*);
template<> ::envoy::config::core::v3::HeaderValue* Arena::CreateMaybeMessage<::envoy::config::core::v3::HeaderValue>(Arena*);
template<> ::envoy::config::core::v3::HeaderValueOption* Arena::CreateMaybeMessage<::envoy::config::core::v3::HeaderValueOption>(Arena*);
template<> ::envoy::config::core::v3::Locality* Arena::CreateMaybeMessage<::envoy::config::core::v3::Locality>(Arena*);
template<> ::envoy::config::core::v3::Metadata* Arena::CreateMaybeMessage<::envoy::config::core::v3::Metadata>(Arena*);
template<> ::envoy::config::core::v3::Metadata_FilterMetadataEntry_DoNotUse* Arena::CreateMaybeMessage<::envoy::config::core::v3::Metadata_FilterMetadataEntry_DoNotUse>(Arena*);
template<> ::envoy::config::core::v3::Node* Arena::CreateMaybeMessage<::envoy::config::core::v3::Node>(Arena*);
template<> ::envoy::config::core::v3::RemoteDataSource* Arena::CreateMaybeMessage<::envoy::config::core::v3::RemoteDataSource>(Arena*);
template<> ::envoy::config::core::v3::RetryPolicy* Arena::CreateMaybeMessage<::envoy::config::core::v3::RetryPolicy>(Arena*);
template<> ::envoy::config::core::v3::RuntimeFeatureFlag* Arena::CreateMaybeMessage<::envoy::config::core::v3::RuntimeFeatureFlag>(Arena*);
template<> ::envoy::config::core::v3::RuntimeFractionalPercent* Arena::CreateMaybeMessage<::envoy::config::core::v3::RuntimeFractionalPercent>(Arena*);
template<> ::envoy::config::core::v3::RuntimeUInt32* Arena::CreateMaybeMessage<::envoy::config::core::v3::RuntimeUInt32>(Arena*);
template<> ::envoy::config::core::v3::TransportSocket* Arena::CreateMaybeMessage<::envoy::config::core::v3::TransportSocket>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace envoy {
namespace config {
namespace core {
namespace v3 {

enum RoutingPriority : int {
  DEFAULT = 0,
  HIGH = 1,
  RoutingPriority_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  RoutingPriority_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool RoutingPriority_IsValid(int value);
constexpr RoutingPriority RoutingPriority_MIN = DEFAULT;
constexpr RoutingPriority RoutingPriority_MAX = HIGH;
constexpr int RoutingPriority_ARRAYSIZE = RoutingPriority_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RoutingPriority_descriptor();
template<typename T>
inline const std::string& RoutingPriority_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RoutingPriority>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RoutingPriority_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RoutingPriority_descriptor(), enum_t_value);
}
inline bool RoutingPriority_Parse(
    const std::string& name, RoutingPriority* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RoutingPriority>(
    RoutingPriority_descriptor(), name, value);
}
enum RequestMethod : int {
  METHOD_UNSPECIFIED = 0,
  GET = 1,
  HEAD = 2,
  POST = 3,
  PUT = 4,
  DELETE = 5,
  CONNECT = 6,
  OPTIONS = 7,
  TRACE = 8,
  PATCH = 9,
  RequestMethod_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  RequestMethod_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool RequestMethod_IsValid(int value);
constexpr RequestMethod RequestMethod_MIN = METHOD_UNSPECIFIED;
constexpr RequestMethod RequestMethod_MAX = PATCH;
constexpr int RequestMethod_ARRAYSIZE = RequestMethod_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RequestMethod_descriptor();
template<typename T>
inline const std::string& RequestMethod_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RequestMethod>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RequestMethod_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RequestMethod_descriptor(), enum_t_value);
}
inline bool RequestMethod_Parse(
    const std::string& name, RequestMethod* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RequestMethod>(
    RequestMethod_descriptor(), name, value);
}
enum TrafficDirection : int {
  UNSPECIFIED = 0,
  INBOUND = 1,
  OUTBOUND = 2,
  TrafficDirection_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  TrafficDirection_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool TrafficDirection_IsValid(int value);
constexpr TrafficDirection TrafficDirection_MIN = UNSPECIFIED;
constexpr TrafficDirection TrafficDirection_MAX = OUTBOUND;
constexpr int TrafficDirection_ARRAYSIZE = TrafficDirection_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TrafficDirection_descriptor();
template<typename T>
inline const std::string& TrafficDirection_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TrafficDirection>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TrafficDirection_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TrafficDirection_descriptor(), enum_t_value);
}
inline bool TrafficDirection_Parse(
    const std::string& name, TrafficDirection* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TrafficDirection>(
    TrafficDirection_descriptor(), name, value);
}
// ===================================================================

class Locality :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:envoy.config.core.v3.Locality) */ {
 public:
  Locality();
  virtual ~Locality();

  Locality(const Locality& from);
  Locality(Locality&& from) noexcept
    : Locality() {
    *this = ::std::move(from);
  }

  inline Locality& operator=(const Locality& from) {
    CopyFrom(from);
    return *this;
  }
  inline Locality& operator=(Locality&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Locality& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Locality* internal_default_instance() {
    return reinterpret_cast<const Locality*>(
               &_Locality_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Locality& a, Locality& b) {
    a.Swap(&b);
  }
  inline void Swap(Locality* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Locality* New() const final {
    return CreateMaybeMessage<Locality>(nullptr);
  }

  Locality* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Locality>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Locality& from);
  void MergeFrom(const Locality& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Locality* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "envoy.config.core.v3.Locality";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_envoy_2fconfig_2fcore_2fv3_2fbase_2eproto);
    return ::descriptor_table_envoy_2fconfig_2fcore_2fv3_2fbase_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRegionFieldNumber = 1,
    kZoneFieldNumber = 2,
    kSubZoneFieldNumber = 3,
  };
  // string region = 1;
  void clear_region();
  const std::string& region() const;
  void set_region(const std::string& value);
  void set_region(std::string&& value);
  void set_region(const char* value);
  void set_region(const char* value, size_t size);
  std::string* mutable_region();
  std::string* release_region();
  void set_allocated_region(std::string* region);

  // string zone = 2;
  void clear_zone();
  const std::string& zone() const;
  void set_zone(const std::string& value);
  void set_zone(std::string&& value);
  void set_zone(const char* value);
  void set_zone(const char* value, size_t size);
  std::string* mutable_zone();
  std::string* release_zone();
  void set_allocated_zone(std::string* zone);

  // string sub_zone = 3;
  void clear_sub_zone();
  const std::string& sub_zone() const;
  void set_sub_zone(const std::string& value);
  void set_sub_zone(std::string&& value);
  void set_sub_zone(const char* value);
  void set_sub_zone(const char* value, size_t size);
  std::string* mutable_sub_zone();
  std::string* release_sub_zone();
  void set_allocated_sub_zone(std::string* sub_zone);

  // @@protoc_insertion_point(class_scope:envoy.config.core.v3.Locality)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr region_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr zone_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sub_zone_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_envoy_2fconfig_2fcore_2fv3_2fbase_2eproto;
};
// -------------------------------------------------------------------

class BuildVersion :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:envoy.config.core.v3.BuildVersion) */ {
 public:
  BuildVersion();
  virtual ~BuildVersion();

  BuildVersion(const BuildVersion& from);
  BuildVersion(BuildVersion&& from) noexcept
    : BuildVersion() {
    *this = ::std::move(from);
  }

  inline BuildVersion& operator=(const BuildVersion& from) {
    CopyFrom(from);
    return *this;
  }
  inline BuildVersion& operator=(BuildVersion&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BuildVersion& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BuildVersion* internal_default_instance() {
    return reinterpret_cast<const BuildVersion*>(
               &_BuildVersion_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(BuildVersion& a, BuildVersion& b) {
    a.Swap(&b);
  }
  inline void Swap(BuildVersion* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BuildVersion* New() const final {
    return CreateMaybeMessage<BuildVersion>(nullptr);
  }

  BuildVersion* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BuildVersion>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BuildVersion& from);
  void MergeFrom(const BuildVersion& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BuildVersion* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "envoy.config.core.v3.BuildVersion";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_envoy_2fconfig_2fcore_2fv3_2fbase_2eproto);
    return ::descriptor_table_envoy_2fconfig_2fcore_2fv3_2fbase_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVersionFieldNumber = 1,
    kMetadataFieldNumber = 2,
  };
  // .envoy.type.v3.SemanticVersion version = 1;
  bool has_version() const;
  void clear_version();
  const ::envoy::type::v3::SemanticVersion& version() const;
  ::envoy::type::v3::SemanticVersion* release_version();
  ::envoy::type::v3::SemanticVersion* mutable_version();
  void set_allocated_version(::envoy::type::v3::SemanticVersion* version);

  // .google.protobuf.Struct metadata = 2;
  bool has_metadata() const;
  void clear_metadata();
  const PROTOBUF_NAMESPACE_ID::Struct& metadata() const;
  PROTOBUF_NAMESPACE_ID::Struct* release_metadata();
  PROTOBUF_NAMESPACE_ID::Struct* mutable_metadata();
  void set_allocated_metadata(PROTOBUF_NAMESPACE_ID::Struct* metadata);

  // @@protoc_insertion_point(class_scope:envoy.config.core.v3.BuildVersion)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::envoy::type::v3::SemanticVersion* version_;
  PROTOBUF_NAMESPACE_ID::Struct* metadata_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_envoy_2fconfig_2fcore_2fv3_2fbase_2eproto;
};
// -------------------------------------------------------------------

class Extension :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:envoy.config.core.v3.Extension) */ {
 public:
  Extension();
  virtual ~Extension();

  Extension(const Extension& from);
  Extension(Extension&& from) noexcept
    : Extension() {
    *this = ::std::move(from);
  }

  inline Extension& operator=(const Extension& from) {
    CopyFrom(from);
    return *this;
  }
  inline Extension& operator=(Extension&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Extension& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Extension* internal_default_instance() {
    return reinterpret_cast<const Extension*>(
               &_Extension_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Extension& a, Extension& b) {
    a.Swap(&b);
  }
  inline void Swap(Extension* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Extension* New() const final {
    return CreateMaybeMessage<Extension>(nullptr);
  }

  Extension* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Extension>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Extension& from);
  void MergeFrom(const Extension& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Extension* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "envoy.config.core.v3.Extension";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_envoy_2fconfig_2fcore_2fv3_2fbase_2eproto);
    return ::descriptor_table_envoy_2fconfig_2fcore_2fv3_2fbase_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kCategoryFieldNumber = 2,
    kTypeDescriptorFieldNumber = 3,
    kVersionFieldNumber = 4,
    kDisabledFieldNumber = 5,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);

  // string category = 2;
  void clear_category();
  const std::string& category() const;
  void set_category(const std::string& value);
  void set_category(std::string&& value);
  void set_category(const char* value);
  void set_category(const char* value, size_t size);
  std::string* mutable_category();
  std::string* release_category();
  void set_allocated_category(std::string* category);

  // string type_descriptor = 3;
  void clear_type_descriptor();
  const std::string& type_descriptor() const;
  void set_type_descriptor(const std::string& value);
  void set_type_descriptor(std::string&& value);
  void set_type_descriptor(const char* value);
  void set_type_descriptor(const char* value, size_t size);
  std::string* mutable_type_descriptor();
  std::string* release_type_descriptor();
  void set_allocated_type_descriptor(std::string* type_descriptor);

  // .envoy.config.core.v3.BuildVersion version = 4;
  bool has_version() const;
  void clear_version();
  const ::envoy::config::core::v3::BuildVersion& version() const;
  ::envoy::config::core::v3::BuildVersion* release_version();
  ::envoy::config::core::v3::BuildVersion* mutable_version();
  void set_allocated_version(::envoy::config::core::v3::BuildVersion* version);

  // bool disabled = 5;
  void clear_disabled();
  bool disabled() const;
  void set_disabled(bool value);

  // @@protoc_insertion_point(class_scope:envoy.config.core.v3.Extension)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr category_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_descriptor_;
  ::envoy::config::core::v3::BuildVersion* version_;
  bool disabled_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_envoy_2fconfig_2fcore_2fv3_2fbase_2eproto;
};
// -------------------------------------------------------------------

class Node :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:envoy.config.core.v3.Node) */ {
 public:
  Node();
  virtual ~Node();

  Node(const Node& from);
  Node(Node&& from) noexcept
    : Node() {
    *this = ::std::move(from);
  }

  inline Node& operator=(const Node& from) {
    CopyFrom(from);
    return *this;
  }
  inline Node& operator=(Node&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Node& default_instance();

  enum UserAgentVersionTypeCase {
    kUserAgentVersion = 7,
    kUserAgentBuildVersion = 8,
    USER_AGENT_VERSION_TYPE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Node* internal_default_instance() {
    return reinterpret_cast<const Node*>(
               &_Node_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Node& a, Node& b) {
    a.Swap(&b);
  }
  inline void Swap(Node* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Node* New() const final {
    return CreateMaybeMessage<Node>(nullptr);
  }

  Node* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Node>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Node& from);
  void MergeFrom(const Node& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Node* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "envoy.config.core.v3.Node";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_envoy_2fconfig_2fcore_2fv3_2fbase_2eproto);
    return ::descriptor_table_envoy_2fconfig_2fcore_2fv3_2fbase_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExtensionsFieldNumber = 9,
    kClientFeaturesFieldNumber = 10,
    kListeningAddressesFieldNumber = 11,
    kIdFieldNumber = 1,
    kClusterFieldNumber = 2,
    kUserAgentNameFieldNumber = 6,
    kMetadataFieldNumber = 3,
    kLocalityFieldNumber = 4,
    kUserAgentVersionFieldNumber = 7,
    kUserAgentBuildVersionFieldNumber = 8,
  };
  // repeated .envoy.config.core.v3.Extension extensions = 9;
  int extensions_size() const;
  void clear_extensions();
  ::envoy::config::core::v3::Extension* mutable_extensions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::envoy::config::core::v3::Extension >*
      mutable_extensions();
  const ::envoy::config::core::v3::Extension& extensions(int index) const;
  ::envoy::config::core::v3::Extension* add_extensions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::envoy::config::core::v3::Extension >&
      extensions() const;

  // repeated string client_features = 10;
  int client_features_size() const;
  void clear_client_features();
  const std::string& client_features(int index) const;
  std::string* mutable_client_features(int index);
  void set_client_features(int index, const std::string& value);
  void set_client_features(int index, std::string&& value);
  void set_client_features(int index, const char* value);
  void set_client_features(int index, const char* value, size_t size);
  std::string* add_client_features();
  void add_client_features(const std::string& value);
  void add_client_features(std::string&& value);
  void add_client_features(const char* value);
  void add_client_features(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& client_features() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_client_features();

  // repeated .envoy.config.core.v3.Address listening_addresses = 11;
  int listening_addresses_size() const;
  void clear_listening_addresses();
  ::envoy::config::core::v3::Address* mutable_listening_addresses(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::envoy::config::core::v3::Address >*
      mutable_listening_addresses();
  const ::envoy::config::core::v3::Address& listening_addresses(int index) const;
  ::envoy::config::core::v3::Address* add_listening_addresses();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::envoy::config::core::v3::Address >&
      listening_addresses() const;

  // string id = 1;
  void clear_id();
  const std::string& id() const;
  void set_id(const std::string& value);
  void set_id(std::string&& value);
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  std::string* mutable_id();
  std::string* release_id();
  void set_allocated_id(std::string* id);

  // string cluster = 2;
  void clear_cluster();
  const std::string& cluster() const;
  void set_cluster(const std::string& value);
  void set_cluster(std::string&& value);
  void set_cluster(const char* value);
  void set_cluster(const char* value, size_t size);
  std::string* mutable_cluster();
  std::string* release_cluster();
  void set_allocated_cluster(std::string* cluster);

  // string user_agent_name = 6;
  void clear_user_agent_name();
  const std::string& user_agent_name() const;
  void set_user_agent_name(const std::string& value);
  void set_user_agent_name(std::string&& value);
  void set_user_agent_name(const char* value);
  void set_user_agent_name(const char* value, size_t size);
  std::string* mutable_user_agent_name();
  std::string* release_user_agent_name();
  void set_allocated_user_agent_name(std::string* user_agent_name);

  // .google.protobuf.Struct metadata = 3;
  bool has_metadata() const;
  void clear_metadata();
  const PROTOBUF_NAMESPACE_ID::Struct& metadata() const;
  PROTOBUF_NAMESPACE_ID::Struct* release_metadata();
  PROTOBUF_NAMESPACE_ID::Struct* mutable_metadata();
  void set_allocated_metadata(PROTOBUF_NAMESPACE_ID::Struct* metadata);

  // .envoy.config.core.v3.Locality locality = 4;
  bool has_locality() const;
  void clear_locality();
  const ::envoy::config::core::v3::Locality& locality() const;
  ::envoy::config::core::v3::Locality* release_locality();
  ::envoy::config::core::v3::Locality* mutable_locality();
  void set_allocated_locality(::envoy::config::core::v3::Locality* locality);

  // string user_agent_version = 7;
  private:
  bool has_user_agent_version() const;
  public:
  void clear_user_agent_version();
  const std::string& user_agent_version() const;
  void set_user_agent_version(const std::string& value);
  void set_user_agent_version(std::string&& value);
  void set_user_agent_version(const char* value);
  void set_user_agent_version(const char* value, size_t size);
  std::string* mutable_user_agent_version();
  std::string* release_user_agent_version();
  void set_allocated_user_agent_version(std::string* user_agent_version);

  // .envoy.config.core.v3.BuildVersion user_agent_build_version = 8;
  bool has_user_agent_build_version() const;
  void clear_user_agent_build_version();
  const ::envoy::config::core::v3::BuildVersion& user_agent_build_version() const;
  ::envoy::config::core::v3::BuildVersion* release_user_agent_build_version();
  ::envoy::config::core::v3::BuildVersion* mutable_user_agent_build_version();
  void set_allocated_user_agent_build_version(::envoy::config::core::v3::BuildVersion* user_agent_build_version);

  void clear_user_agent_version_type();
  UserAgentVersionTypeCase user_agent_version_type_case() const;
  // @@protoc_insertion_point(class_scope:envoy.config.core.v3.Node)
 private:
  class _Internal;
  void set_has_user_agent_version();
  void set_has_user_agent_build_version();

  inline bool has_user_agent_version_type() const;
  inline void clear_has_user_agent_version_type();

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::envoy::config::core::v3::Extension > extensions_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> client_features_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::envoy::config::core::v3::Address > listening_addresses_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cluster_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_agent_name_;
  PROTOBUF_NAMESPACE_ID::Struct* metadata_;
  ::envoy::config::core::v3::Locality* locality_;
  union UserAgentVersionTypeUnion {
    UserAgentVersionTypeUnion() {}
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_agent_version_;
    ::envoy::config::core::v3::BuildVersion* user_agent_build_version_;
  } user_agent_version_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_envoy_2fconfig_2fcore_2fv3_2fbase_2eproto;
};
// -------------------------------------------------------------------

class Metadata_FilterMetadataEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Metadata_FilterMetadataEntry_DoNotUse, 
    std::string, PROTOBUF_NAMESPACE_ID::Struct,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Metadata_FilterMetadataEntry_DoNotUse, 
    std::string, PROTOBUF_NAMESPACE_ID::Struct,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  Metadata_FilterMetadataEntry_DoNotUse();
  Metadata_FilterMetadataEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Metadata_FilterMetadataEntry_DoNotUse& other);
  static const Metadata_FilterMetadataEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Metadata_FilterMetadataEntry_DoNotUse*>(&_Metadata_FilterMetadataEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), s->size(), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "envoy.config.core.v3.Metadata.FilterMetadataEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_envoy_2fconfig_2fcore_2fv3_2fbase_2eproto);
    return ::descriptor_table_envoy_2fconfig_2fcore_2fv3_2fbase_2eproto.file_level_metadata[4];
  }

  public:
};

// -------------------------------------------------------------------

class Metadata :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:envoy.config.core.v3.Metadata) */ {
 public:
  Metadata();
  virtual ~Metadata();

  Metadata(const Metadata& from);
  Metadata(Metadata&& from) noexcept
    : Metadata() {
    *this = ::std::move(from);
  }

  inline Metadata& operator=(const Metadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline Metadata& operator=(Metadata&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Metadata& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Metadata* internal_default_instance() {
    return reinterpret_cast<const Metadata*>(
               &_Metadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Metadata& a, Metadata& b) {
    a.Swap(&b);
  }
  inline void Swap(Metadata* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Metadata* New() const final {
    return CreateMaybeMessage<Metadata>(nullptr);
  }

  Metadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Metadata>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Metadata& from);
  void MergeFrom(const Metadata& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Metadata* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "envoy.config.core.v3.Metadata";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_envoy_2fconfig_2fcore_2fv3_2fbase_2eproto);
    return ::descriptor_table_envoy_2fconfig_2fcore_2fv3_2fbase_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kFilterMetadataFieldNumber = 1,
  };
  // map<string, .google.protobuf.Struct> filter_metadata = 1;
  int filter_metadata_size() const;
  void clear_filter_metadata();
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, PROTOBUF_NAMESPACE_ID::Struct >&
      filter_metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, PROTOBUF_NAMESPACE_ID::Struct >*
      mutable_filter_metadata();

  // @@protoc_insertion_point(class_scope:envoy.config.core.v3.Metadata)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      Metadata_FilterMetadataEntry_DoNotUse,
      std::string, PROTOBUF_NAMESPACE_ID::Struct,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
      0 > filter_metadata_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_envoy_2fconfig_2fcore_2fv3_2fbase_2eproto;
};
// -------------------------------------------------------------------

class RuntimeUInt32 :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:envoy.config.core.v3.RuntimeUInt32) */ {
 public:
  RuntimeUInt32();
  virtual ~RuntimeUInt32();

  RuntimeUInt32(const RuntimeUInt32& from);
  RuntimeUInt32(RuntimeUInt32&& from) noexcept
    : RuntimeUInt32() {
    *this = ::std::move(from);
  }

  inline RuntimeUInt32& operator=(const RuntimeUInt32& from) {
    CopyFrom(from);
    return *this;
  }
  inline RuntimeUInt32& operator=(RuntimeUInt32&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RuntimeUInt32& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RuntimeUInt32* internal_default_instance() {
    return reinterpret_cast<const RuntimeUInt32*>(
               &_RuntimeUInt32_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(RuntimeUInt32& a, RuntimeUInt32& b) {
    a.Swap(&b);
  }
  inline void Swap(RuntimeUInt32* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RuntimeUInt32* New() const final {
    return CreateMaybeMessage<RuntimeUInt32>(nullptr);
  }

  RuntimeUInt32* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RuntimeUInt32>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RuntimeUInt32& from);
  void MergeFrom(const RuntimeUInt32& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RuntimeUInt32* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "envoy.config.core.v3.RuntimeUInt32";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_envoy_2fconfig_2fcore_2fv3_2fbase_2eproto);
    return ::descriptor_table_envoy_2fconfig_2fcore_2fv3_2fbase_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRuntimeKeyFieldNumber = 3,
    kDefaultValueFieldNumber = 2,
  };
  // string runtime_key = 3 [(.validate.rules) = {
  void clear_runtime_key();
  const std::string& runtime_key() const;
  void set_runtime_key(const std::string& value);
  void set_runtime_key(std::string&& value);
  void set_runtime_key(const char* value);
  void set_runtime_key(const char* value, size_t size);
  std::string* mutable_runtime_key();
  std::string* release_runtime_key();
  void set_allocated_runtime_key(std::string* runtime_key);

  // uint32 default_value = 2;
  void clear_default_value();
  ::PROTOBUF_NAMESPACE_ID::uint32 default_value() const;
  void set_default_value(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:envoy.config.core.v3.RuntimeUInt32)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr runtime_key_;
  ::PROTOBUF_NAMESPACE_ID::uint32 default_value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_envoy_2fconfig_2fcore_2fv3_2fbase_2eproto;
};
// -------------------------------------------------------------------

class RuntimeFeatureFlag :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:envoy.config.core.v3.RuntimeFeatureFlag) */ {
 public:
  RuntimeFeatureFlag();
  virtual ~RuntimeFeatureFlag();

  RuntimeFeatureFlag(const RuntimeFeatureFlag& from);
  RuntimeFeatureFlag(RuntimeFeatureFlag&& from) noexcept
    : RuntimeFeatureFlag() {
    *this = ::std::move(from);
  }

  inline RuntimeFeatureFlag& operator=(const RuntimeFeatureFlag& from) {
    CopyFrom(from);
    return *this;
  }
  inline RuntimeFeatureFlag& operator=(RuntimeFeatureFlag&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RuntimeFeatureFlag& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RuntimeFeatureFlag* internal_default_instance() {
    return reinterpret_cast<const RuntimeFeatureFlag*>(
               &_RuntimeFeatureFlag_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(RuntimeFeatureFlag& a, RuntimeFeatureFlag& b) {
    a.Swap(&b);
  }
  inline void Swap(RuntimeFeatureFlag* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RuntimeFeatureFlag* New() const final {
    return CreateMaybeMessage<RuntimeFeatureFlag>(nullptr);
  }

  RuntimeFeatureFlag* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RuntimeFeatureFlag>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RuntimeFeatureFlag& from);
  void MergeFrom(const RuntimeFeatureFlag& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RuntimeFeatureFlag* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "envoy.config.core.v3.RuntimeFeatureFlag";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_envoy_2fconfig_2fcore_2fv3_2fbase_2eproto);
    return ::descriptor_table_envoy_2fconfig_2fcore_2fv3_2fbase_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRuntimeKeyFieldNumber = 2,
    kDefaultValueFieldNumber = 1,
  };
  // string runtime_key = 2 [(.validate.rules) = {
  void clear_runtime_key();
  const std::string& runtime_key() const;
  void set_runtime_key(const std::string& value);
  void set_runtime_key(std::string&& value);
  void set_runtime_key(const char* value);
  void set_runtime_key(const char* value, size_t size);
  std::string* mutable_runtime_key();
  std::string* release_runtime_key();
  void set_allocated_runtime_key(std::string* runtime_key);

  // .google.protobuf.BoolValue default_value = 1 [(.validate.rules) = {
  bool has_default_value() const;
  void clear_default_value();
  const PROTOBUF_NAMESPACE_ID::BoolValue& default_value() const;
  PROTOBUF_NAMESPACE_ID::BoolValue* release_default_value();
  PROTOBUF_NAMESPACE_ID::BoolValue* mutable_default_value();
  void set_allocated_default_value(PROTOBUF_NAMESPACE_ID::BoolValue* default_value);

  // @@protoc_insertion_point(class_scope:envoy.config.core.v3.RuntimeFeatureFlag)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr runtime_key_;
  PROTOBUF_NAMESPACE_ID::BoolValue* default_value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_envoy_2fconfig_2fcore_2fv3_2fbase_2eproto;
};
// -------------------------------------------------------------------

class HeaderValue :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:envoy.config.core.v3.HeaderValue) */ {
 public:
  HeaderValue();
  virtual ~HeaderValue();

  HeaderValue(const HeaderValue& from);
  HeaderValue(HeaderValue&& from) noexcept
    : HeaderValue() {
    *this = ::std::move(from);
  }

  inline HeaderValue& operator=(const HeaderValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline HeaderValue& operator=(HeaderValue&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const HeaderValue& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HeaderValue* internal_default_instance() {
    return reinterpret_cast<const HeaderValue*>(
               &_HeaderValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(HeaderValue& a, HeaderValue& b) {
    a.Swap(&b);
  }
  inline void Swap(HeaderValue* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline HeaderValue* New() const final {
    return CreateMaybeMessage<HeaderValue>(nullptr);
  }

  HeaderValue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<HeaderValue>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const HeaderValue& from);
  void MergeFrom(const HeaderValue& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HeaderValue* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "envoy.config.core.v3.HeaderValue";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_envoy_2fconfig_2fcore_2fv3_2fbase_2eproto);
    return ::descriptor_table_envoy_2fconfig_2fcore_2fv3_2fbase_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // string key = 1 [(.validate.rules) = {
  void clear_key();
  const std::string& key() const;
  void set_key(const std::string& value);
  void set_key(std::string&& value);
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  std::string* mutable_key();
  std::string* release_key();
  void set_allocated_key(std::string* key);

  // string value = 2 [(.validate.rules) = {
  void clear_value();
  const std::string& value() const;
  void set_value(const std::string& value);
  void set_value(std::string&& value);
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  std::string* mutable_value();
  std::string* release_value();
  void set_allocated_value(std::string* value);

  // @@protoc_insertion_point(class_scope:envoy.config.core.v3.HeaderValue)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_envoy_2fconfig_2fcore_2fv3_2fbase_2eproto;
};
// -------------------------------------------------------------------

class HeaderValueOption :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:envoy.config.core.v3.HeaderValueOption) */ {
 public:
  HeaderValueOption();
  virtual ~HeaderValueOption();

  HeaderValueOption(const HeaderValueOption& from);
  HeaderValueOption(HeaderValueOption&& from) noexcept
    : HeaderValueOption() {
    *this = ::std::move(from);
  }

  inline HeaderValueOption& operator=(const HeaderValueOption& from) {
    CopyFrom(from);
    return *this;
  }
  inline HeaderValueOption& operator=(HeaderValueOption&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const HeaderValueOption& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HeaderValueOption* internal_default_instance() {
    return reinterpret_cast<const HeaderValueOption*>(
               &_HeaderValueOption_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(HeaderValueOption& a, HeaderValueOption& b) {
    a.Swap(&b);
  }
  inline void Swap(HeaderValueOption* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline HeaderValueOption* New() const final {
    return CreateMaybeMessage<HeaderValueOption>(nullptr);
  }

  HeaderValueOption* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<HeaderValueOption>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const HeaderValueOption& from);
  void MergeFrom(const HeaderValueOption& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HeaderValueOption* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "envoy.config.core.v3.HeaderValueOption";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_envoy_2fconfig_2fcore_2fv3_2fbase_2eproto);
    return ::descriptor_table_envoy_2fconfig_2fcore_2fv3_2fbase_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kAppendFieldNumber = 2,
  };
  // .envoy.config.core.v3.HeaderValue header = 1 [(.validate.rules) = {
  bool has_header() const;
  void clear_header();
  const ::envoy::config::core::v3::HeaderValue& header() const;
  ::envoy::config::core::v3::HeaderValue* release_header();
  ::envoy::config::core::v3::HeaderValue* mutable_header();
  void set_allocated_header(::envoy::config::core::v3::HeaderValue* header);

  // .google.protobuf.BoolValue append = 2;
  bool has_append() const;
  void clear_append();
  const PROTOBUF_NAMESPACE_ID::BoolValue& append() const;
  PROTOBUF_NAMESPACE_ID::BoolValue* release_append();
  PROTOBUF_NAMESPACE_ID::BoolValue* mutable_append();
  void set_allocated_append(PROTOBUF_NAMESPACE_ID::BoolValue* append);

  // @@protoc_insertion_point(class_scope:envoy.config.core.v3.HeaderValueOption)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::envoy::config::core::v3::HeaderValue* header_;
  PROTOBUF_NAMESPACE_ID::BoolValue* append_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_envoy_2fconfig_2fcore_2fv3_2fbase_2eproto;
};
// -------------------------------------------------------------------

class HeaderMap :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:envoy.config.core.v3.HeaderMap) */ {
 public:
  HeaderMap();
  virtual ~HeaderMap();

  HeaderMap(const HeaderMap& from);
  HeaderMap(HeaderMap&& from) noexcept
    : HeaderMap() {
    *this = ::std::move(from);
  }

  inline HeaderMap& operator=(const HeaderMap& from) {
    CopyFrom(from);
    return *this;
  }
  inline HeaderMap& operator=(HeaderMap&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const HeaderMap& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HeaderMap* internal_default_instance() {
    return reinterpret_cast<const HeaderMap*>(
               &_HeaderMap_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(HeaderMap& a, HeaderMap& b) {
    a.Swap(&b);
  }
  inline void Swap(HeaderMap* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline HeaderMap* New() const final {
    return CreateMaybeMessage<HeaderMap>(nullptr);
  }

  HeaderMap* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<HeaderMap>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const HeaderMap& from);
  void MergeFrom(const HeaderMap& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HeaderMap* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "envoy.config.core.v3.HeaderMap";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_envoy_2fconfig_2fcore_2fv3_2fbase_2eproto);
    return ::descriptor_table_envoy_2fconfig_2fcore_2fv3_2fbase_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeadersFieldNumber = 1,
  };
  // repeated .envoy.config.core.v3.HeaderValue headers = 1;
  int headers_size() const;
  void clear_headers();
  ::envoy::config::core::v3::HeaderValue* mutable_headers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::envoy::config::core::v3::HeaderValue >*
      mutable_headers();
  const ::envoy::config::core::v3::HeaderValue& headers(int index) const;
  ::envoy::config::core::v3::HeaderValue* add_headers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::envoy::config::core::v3::HeaderValue >&
      headers() const;

  // @@protoc_insertion_point(class_scope:envoy.config.core.v3.HeaderMap)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::envoy::config::core::v3::HeaderValue > headers_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_envoy_2fconfig_2fcore_2fv3_2fbase_2eproto;
};
// -------------------------------------------------------------------

class DataSource :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:envoy.config.core.v3.DataSource) */ {
 public:
  DataSource();
  virtual ~DataSource();

  DataSource(const DataSource& from);
  DataSource(DataSource&& from) noexcept
    : DataSource() {
    *this = ::std::move(from);
  }

  inline DataSource& operator=(const DataSource& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataSource& operator=(DataSource&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DataSource& default_instance();

  enum SpecifierCase {
    kFilename = 1,
    kInlineBytes = 2,
    kInlineString = 3,
    SPECIFIER_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DataSource* internal_default_instance() {
    return reinterpret_cast<const DataSource*>(
               &_DataSource_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(DataSource& a, DataSource& b) {
    a.Swap(&b);
  }
  inline void Swap(DataSource* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DataSource* New() const final {
    return CreateMaybeMessage<DataSource>(nullptr);
  }

  DataSource* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DataSource>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DataSource& from);
  void MergeFrom(const DataSource& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DataSource* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "envoy.config.core.v3.DataSource";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_envoy_2fconfig_2fcore_2fv3_2fbase_2eproto);
    return ::descriptor_table_envoy_2fconfig_2fcore_2fv3_2fbase_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFilenameFieldNumber = 1,
    kInlineBytesFieldNumber = 2,
    kInlineStringFieldNumber = 3,
  };
  // string filename = 1 [(.validate.rules) = {
  private:
  bool has_filename() const;
  public:
  void clear_filename();
  const std::string& filename() const;
  void set_filename(const std::string& value);
  void set_filename(std::string&& value);
  void set_filename(const char* value);
  void set_filename(const char* value, size_t size);
  std::string* mutable_filename();
  std::string* release_filename();
  void set_allocated_filename(std::string* filename);

  // bytes inline_bytes = 2 [(.validate.rules) = {
  private:
  bool has_inline_bytes() const;
  public:
  void clear_inline_bytes();
  const std::string& inline_bytes() const;
  void set_inline_bytes(const std::string& value);
  void set_inline_bytes(std::string&& value);
  void set_inline_bytes(const char* value);
  void set_inline_bytes(const void* value, size_t size);
  std::string* mutable_inline_bytes();
  std::string* release_inline_bytes();
  void set_allocated_inline_bytes(std::string* inline_bytes);

  // string inline_string = 3 [(.validate.rules) = {
  private:
  bool has_inline_string() const;
  public:
  void clear_inline_string();
  const std::string& inline_string() const;
  void set_inline_string(const std::string& value);
  void set_inline_string(std::string&& value);
  void set_inline_string(const char* value);
  void set_inline_string(const char* value, size_t size);
  std::string* mutable_inline_string();
  std::string* release_inline_string();
  void set_allocated_inline_string(std::string* inline_string);

  void clear_specifier();
  SpecifierCase specifier_case() const;
  // @@protoc_insertion_point(class_scope:envoy.config.core.v3.DataSource)
 private:
  class _Internal;
  void set_has_filename();
  void set_has_inline_bytes();
  void set_has_inline_string();

  inline bool has_specifier() const;
  inline void clear_has_specifier();

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  union SpecifierUnion {
    SpecifierUnion() {}
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filename_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr inline_bytes_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr inline_string_;
  } specifier_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_envoy_2fconfig_2fcore_2fv3_2fbase_2eproto;
};
// -------------------------------------------------------------------

class RetryPolicy :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:envoy.config.core.v3.RetryPolicy) */ {
 public:
  RetryPolicy();
  virtual ~RetryPolicy();

  RetryPolicy(const RetryPolicy& from);
  RetryPolicy(RetryPolicy&& from) noexcept
    : RetryPolicy() {
    *this = ::std::move(from);
  }

  inline RetryPolicy& operator=(const RetryPolicy& from) {
    CopyFrom(from);
    return *this;
  }
  inline RetryPolicy& operator=(RetryPolicy&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RetryPolicy& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RetryPolicy* internal_default_instance() {
    return reinterpret_cast<const RetryPolicy*>(
               &_RetryPolicy_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(RetryPolicy& a, RetryPolicy& b) {
    a.Swap(&b);
  }
  inline void Swap(RetryPolicy* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RetryPolicy* New() const final {
    return CreateMaybeMessage<RetryPolicy>(nullptr);
  }

  RetryPolicy* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RetryPolicy>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RetryPolicy& from);
  void MergeFrom(const RetryPolicy& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RetryPolicy* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "envoy.config.core.v3.RetryPolicy";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_envoy_2fconfig_2fcore_2fv3_2fbase_2eproto);
    return ::descriptor_table_envoy_2fconfig_2fcore_2fv3_2fbase_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRetryBackOffFieldNumber = 1,
    kNumRetriesFieldNumber = 2,
  };
  // .envoy.config.core.v3.BackoffStrategy retry_back_off = 1;
  bool has_retry_back_off() const;
  void clear_retry_back_off();
  const ::envoy::config::core::v3::BackoffStrategy& retry_back_off() const;
  ::envoy::config::core::v3::BackoffStrategy* release_retry_back_off();
  ::envoy::config::core::v3::BackoffStrategy* mutable_retry_back_off();
  void set_allocated_retry_back_off(::envoy::config::core::v3::BackoffStrategy* retry_back_off);

  // .google.protobuf.UInt32Value num_retries = 2;
  bool has_num_retries() const;
  void clear_num_retries();
  const PROTOBUF_NAMESPACE_ID::UInt32Value& num_retries() const;
  PROTOBUF_NAMESPACE_ID::UInt32Value* release_num_retries();
  PROTOBUF_NAMESPACE_ID::UInt32Value* mutable_num_retries();
  void set_allocated_num_retries(PROTOBUF_NAMESPACE_ID::UInt32Value* num_retries);

  // @@protoc_insertion_point(class_scope:envoy.config.core.v3.RetryPolicy)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::envoy::config::core::v3::BackoffStrategy* retry_back_off_;
  PROTOBUF_NAMESPACE_ID::UInt32Value* num_retries_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_envoy_2fconfig_2fcore_2fv3_2fbase_2eproto;
};
// -------------------------------------------------------------------

class RemoteDataSource :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:envoy.config.core.v3.RemoteDataSource) */ {
 public:
  RemoteDataSource();
  virtual ~RemoteDataSource();

  RemoteDataSource(const RemoteDataSource& from);
  RemoteDataSource(RemoteDataSource&& from) noexcept
    : RemoteDataSource() {
    *this = ::std::move(from);
  }

  inline RemoteDataSource& operator=(const RemoteDataSource& from) {
    CopyFrom(from);
    return *this;
  }
  inline RemoteDataSource& operator=(RemoteDataSource&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RemoteDataSource& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RemoteDataSource* internal_default_instance() {
    return reinterpret_cast<const RemoteDataSource*>(
               &_RemoteDataSource_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(RemoteDataSource& a, RemoteDataSource& b) {
    a.Swap(&b);
  }
  inline void Swap(RemoteDataSource* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RemoteDataSource* New() const final {
    return CreateMaybeMessage<RemoteDataSource>(nullptr);
  }

  RemoteDataSource* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RemoteDataSource>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RemoteDataSource& from);
  void MergeFrom(const RemoteDataSource& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RemoteDataSource* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "envoy.config.core.v3.RemoteDataSource";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_envoy_2fconfig_2fcore_2fv3_2fbase_2eproto);
    return ::descriptor_table_envoy_2fconfig_2fcore_2fv3_2fbase_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSha256FieldNumber = 2,
    kHttpUriFieldNumber = 1,
    kRetryPolicyFieldNumber = 3,
  };
  // string sha256 = 2 [(.validate.rules) = {
  void clear_sha256();
  const std::string& sha256() const;
  void set_sha256(const std::string& value);
  void set_sha256(std::string&& value);
  void set_sha256(const char* value);
  void set_sha256(const char* value, size_t size);
  std::string* mutable_sha256();
  std::string* release_sha256();
  void set_allocated_sha256(std::string* sha256);

  // .envoy.config.core.v3.HttpUri http_uri = 1 [(.validate.rules) = {
  bool has_http_uri() const;
  void clear_http_uri();
  const ::envoy::config::core::v3::HttpUri& http_uri() const;
  ::envoy::config::core::v3::HttpUri* release_http_uri();
  ::envoy::config::core::v3::HttpUri* mutable_http_uri();
  void set_allocated_http_uri(::envoy::config::core::v3::HttpUri* http_uri);

  // .envoy.config.core.v3.RetryPolicy retry_policy = 3;
  bool has_retry_policy() const;
  void clear_retry_policy();
  const ::envoy::config::core::v3::RetryPolicy& retry_policy() const;
  ::envoy::config::core::v3::RetryPolicy* release_retry_policy();
  ::envoy::config::core::v3::RetryPolicy* mutable_retry_policy();
  void set_allocated_retry_policy(::envoy::config::core::v3::RetryPolicy* retry_policy);

  // @@protoc_insertion_point(class_scope:envoy.config.core.v3.RemoteDataSource)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sha256_;
  ::envoy::config::core::v3::HttpUri* http_uri_;
  ::envoy::config::core::v3::RetryPolicy* retry_policy_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_envoy_2fconfig_2fcore_2fv3_2fbase_2eproto;
};
// -------------------------------------------------------------------

class AsyncDataSource :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:envoy.config.core.v3.AsyncDataSource) */ {
 public:
  AsyncDataSource();
  virtual ~AsyncDataSource();

  AsyncDataSource(const AsyncDataSource& from);
  AsyncDataSource(AsyncDataSource&& from) noexcept
    : AsyncDataSource() {
    *this = ::std::move(from);
  }

  inline AsyncDataSource& operator=(const AsyncDataSource& from) {
    CopyFrom(from);
    return *this;
  }
  inline AsyncDataSource& operator=(AsyncDataSource&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AsyncDataSource& default_instance();

  enum SpecifierCase {
    kLocal = 1,
    kRemote = 2,
    SPECIFIER_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AsyncDataSource* internal_default_instance() {
    return reinterpret_cast<const AsyncDataSource*>(
               &_AsyncDataSource_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(AsyncDataSource& a, AsyncDataSource& b) {
    a.Swap(&b);
  }
  inline void Swap(AsyncDataSource* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AsyncDataSource* New() const final {
    return CreateMaybeMessage<AsyncDataSource>(nullptr);
  }

  AsyncDataSource* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AsyncDataSource>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AsyncDataSource& from);
  void MergeFrom(const AsyncDataSource& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AsyncDataSource* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "envoy.config.core.v3.AsyncDataSource";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_envoy_2fconfig_2fcore_2fv3_2fbase_2eproto);
    return ::descriptor_table_envoy_2fconfig_2fcore_2fv3_2fbase_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLocalFieldNumber = 1,
    kRemoteFieldNumber = 2,
  };
  // .envoy.config.core.v3.DataSource local = 1;
  bool has_local() const;
  void clear_local();
  const ::envoy::config::core::v3::DataSource& local() const;
  ::envoy::config::core::v3::DataSource* release_local();
  ::envoy::config::core::v3::DataSource* mutable_local();
  void set_allocated_local(::envoy::config::core::v3::DataSource* local);

  // .envoy.config.core.v3.RemoteDataSource remote = 2;
  bool has_remote() const;
  void clear_remote();
  const ::envoy::config::core::v3::RemoteDataSource& remote() const;
  ::envoy::config::core::v3::RemoteDataSource* release_remote();
  ::envoy::config::core::v3::RemoteDataSource* mutable_remote();
  void set_allocated_remote(::envoy::config::core::v3::RemoteDataSource* remote);

  void clear_specifier();
  SpecifierCase specifier_case() const;
  // @@protoc_insertion_point(class_scope:envoy.config.core.v3.AsyncDataSource)
 private:
  class _Internal;
  void set_has_local();
  void set_has_remote();

  inline bool has_specifier() const;
  inline void clear_has_specifier();

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  union SpecifierUnion {
    SpecifierUnion() {}
    ::envoy::config::core::v3::DataSource* local_;
    ::envoy::config::core::v3::RemoteDataSource* remote_;
  } specifier_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_envoy_2fconfig_2fcore_2fv3_2fbase_2eproto;
};
// -------------------------------------------------------------------

class TransportSocket :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:envoy.config.core.v3.TransportSocket) */ {
 public:
  TransportSocket();
  virtual ~TransportSocket();

  TransportSocket(const TransportSocket& from);
  TransportSocket(TransportSocket&& from) noexcept
    : TransportSocket() {
    *this = ::std::move(from);
  }

  inline TransportSocket& operator=(const TransportSocket& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransportSocket& operator=(TransportSocket&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TransportSocket& default_instance();

  enum ConfigTypeCase {
    kTypedConfig = 3,
    CONFIG_TYPE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TransportSocket* internal_default_instance() {
    return reinterpret_cast<const TransportSocket*>(
               &_TransportSocket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(TransportSocket& a, TransportSocket& b) {
    a.Swap(&b);
  }
  inline void Swap(TransportSocket* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TransportSocket* New() const final {
    return CreateMaybeMessage<TransportSocket>(nullptr);
  }

  TransportSocket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TransportSocket>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TransportSocket& from);
  void MergeFrom(const TransportSocket& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransportSocket* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "envoy.config.core.v3.TransportSocket";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_envoy_2fconfig_2fcore_2fv3_2fbase_2eproto);
    return ::descriptor_table_envoy_2fconfig_2fcore_2fv3_2fbase_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kTypedConfigFieldNumber = 3,
  };
  // string name = 1 [(.validate.rules) = {
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);

  // .google.protobuf.Any typed_config = 3;
  bool has_typed_config() const;
  void clear_typed_config();
  const PROTOBUF_NAMESPACE_ID::Any& typed_config() const;
  PROTOBUF_NAMESPACE_ID::Any* release_typed_config();
  PROTOBUF_NAMESPACE_ID::Any* mutable_typed_config();
  void set_allocated_typed_config(PROTOBUF_NAMESPACE_ID::Any* typed_config);

  void clear_config_type();
  ConfigTypeCase config_type_case() const;
  // @@protoc_insertion_point(class_scope:envoy.config.core.v3.TransportSocket)
 private:
  class _Internal;
  void set_has_typed_config();

  inline bool has_config_type() const;
  inline void clear_has_config_type();

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  union ConfigTypeUnion {
    ConfigTypeUnion() {}
    PROTOBUF_NAMESPACE_ID::Any* typed_config_;
  } config_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_envoy_2fconfig_2fcore_2fv3_2fbase_2eproto;
};
// -------------------------------------------------------------------

class RuntimeFractionalPercent :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:envoy.config.core.v3.RuntimeFractionalPercent) */ {
 public:
  RuntimeFractionalPercent();
  virtual ~RuntimeFractionalPercent();

  RuntimeFractionalPercent(const RuntimeFractionalPercent& from);
  RuntimeFractionalPercent(RuntimeFractionalPercent&& from) noexcept
    : RuntimeFractionalPercent() {
    *this = ::std::move(from);
  }

  inline RuntimeFractionalPercent& operator=(const RuntimeFractionalPercent& from) {
    CopyFrom(from);
    return *this;
  }
  inline RuntimeFractionalPercent& operator=(RuntimeFractionalPercent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RuntimeFractionalPercent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RuntimeFractionalPercent* internal_default_instance() {
    return reinterpret_cast<const RuntimeFractionalPercent*>(
               &_RuntimeFractionalPercent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(RuntimeFractionalPercent& a, RuntimeFractionalPercent& b) {
    a.Swap(&b);
  }
  inline void Swap(RuntimeFractionalPercent* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RuntimeFractionalPercent* New() const final {
    return CreateMaybeMessage<RuntimeFractionalPercent>(nullptr);
  }

  RuntimeFractionalPercent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RuntimeFractionalPercent>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RuntimeFractionalPercent& from);
  void MergeFrom(const RuntimeFractionalPercent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RuntimeFractionalPercent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "envoy.config.core.v3.RuntimeFractionalPercent";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_envoy_2fconfig_2fcore_2fv3_2fbase_2eproto);
    return ::descriptor_table_envoy_2fconfig_2fcore_2fv3_2fbase_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRuntimeKeyFieldNumber = 2,
    kDefaultValueFieldNumber = 1,
  };
  // string runtime_key = 2;
  void clear_runtime_key();
  const std::string& runtime_key() const;
  void set_runtime_key(const std::string& value);
  void set_runtime_key(std::string&& value);
  void set_runtime_key(const char* value);
  void set_runtime_key(const char* value, size_t size);
  std::string* mutable_runtime_key();
  std::string* release_runtime_key();
  void set_allocated_runtime_key(std::string* runtime_key);

  // .envoy.type.v3.FractionalPercent default_value = 1 [(.validate.rules) = {
  bool has_default_value() const;
  void clear_default_value();
  const ::envoy::type::v3::FractionalPercent& default_value() const;
  ::envoy::type::v3::FractionalPercent* release_default_value();
  ::envoy::type::v3::FractionalPercent* mutable_default_value();
  void set_allocated_default_value(::envoy::type::v3::FractionalPercent* default_value);

  // @@protoc_insertion_point(class_scope:envoy.config.core.v3.RuntimeFractionalPercent)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr runtime_key_;
  ::envoy::type::v3::FractionalPercent* default_value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_envoy_2fconfig_2fcore_2fv3_2fbase_2eproto;
};
// -------------------------------------------------------------------

class ControlPlane :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:envoy.config.core.v3.ControlPlane) */ {
 public:
  ControlPlane();
  virtual ~ControlPlane();

  ControlPlane(const ControlPlane& from);
  ControlPlane(ControlPlane&& from) noexcept
    : ControlPlane() {
    *this = ::std::move(from);
  }

  inline ControlPlane& operator=(const ControlPlane& from) {
    CopyFrom(from);
    return *this;
  }
  inline ControlPlane& operator=(ControlPlane&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ControlPlane& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ControlPlane* internal_default_instance() {
    return reinterpret_cast<const ControlPlane*>(
               &_ControlPlane_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(ControlPlane& a, ControlPlane& b) {
    a.Swap(&b);
  }
  inline void Swap(ControlPlane* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ControlPlane* New() const final {
    return CreateMaybeMessage<ControlPlane>(nullptr);
  }

  ControlPlane* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ControlPlane>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ControlPlane& from);
  void MergeFrom(const ControlPlane& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ControlPlane* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "envoy.config.core.v3.ControlPlane";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_envoy_2fconfig_2fcore_2fv3_2fbase_2eproto);
    return ::descriptor_table_envoy_2fconfig_2fcore_2fv3_2fbase_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdentifierFieldNumber = 1,
  };
  // string identifier = 1;
  void clear_identifier();
  const std::string& identifier() const;
  void set_identifier(const std::string& value);
  void set_identifier(std::string&& value);
  void set_identifier(const char* value);
  void set_identifier(const char* value, size_t size);
  std::string* mutable_identifier();
  std::string* release_identifier();
  void set_allocated_identifier(std::string* identifier);

  // @@protoc_insertion_point(class_scope:envoy.config.core.v3.ControlPlane)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr identifier_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_envoy_2fconfig_2fcore_2fv3_2fbase_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Locality

// string region = 1;
inline void Locality::clear_region() {
  region_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Locality::region() const {
  // @@protoc_insertion_point(field_get:envoy.config.core.v3.Locality.region)
  return region_.GetNoArena();
}
inline void Locality::set_region(const std::string& value) {
  
  region_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:envoy.config.core.v3.Locality.region)
}
inline void Locality::set_region(std::string&& value) {
  
  region_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:envoy.config.core.v3.Locality.region)
}
inline void Locality::set_region(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  region_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:envoy.config.core.v3.Locality.region)
}
inline void Locality::set_region(const char* value, size_t size) {
  
  region_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:envoy.config.core.v3.Locality.region)
}
inline std::string* Locality::mutable_region() {
  
  // @@protoc_insertion_point(field_mutable:envoy.config.core.v3.Locality.region)
  return region_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Locality::release_region() {
  // @@protoc_insertion_point(field_release:envoy.config.core.v3.Locality.region)
  
  return region_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Locality::set_allocated_region(std::string* region) {
  if (region != nullptr) {
    
  } else {
    
  }
  region_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), region);
  // @@protoc_insertion_point(field_set_allocated:envoy.config.core.v3.Locality.region)
}

// string zone = 2;
inline void Locality::clear_zone() {
  zone_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Locality::zone() const {
  // @@protoc_insertion_point(field_get:envoy.config.core.v3.Locality.zone)
  return zone_.GetNoArena();
}
inline void Locality::set_zone(const std::string& value) {
  
  zone_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:envoy.config.core.v3.Locality.zone)
}
inline void Locality::set_zone(std::string&& value) {
  
  zone_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:envoy.config.core.v3.Locality.zone)
}
inline void Locality::set_zone(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  zone_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:envoy.config.core.v3.Locality.zone)
}
inline void Locality::set_zone(const char* value, size_t size) {
  
  zone_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:envoy.config.core.v3.Locality.zone)
}
inline std::string* Locality::mutable_zone() {
  
  // @@protoc_insertion_point(field_mutable:envoy.config.core.v3.Locality.zone)
  return zone_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Locality::release_zone() {
  // @@protoc_insertion_point(field_release:envoy.config.core.v3.Locality.zone)
  
  return zone_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Locality::set_allocated_zone(std::string* zone) {
  if (zone != nullptr) {
    
  } else {
    
  }
  zone_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), zone);
  // @@protoc_insertion_point(field_set_allocated:envoy.config.core.v3.Locality.zone)
}

// string sub_zone = 3;
inline void Locality::clear_sub_zone() {
  sub_zone_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Locality::sub_zone() const {
  // @@protoc_insertion_point(field_get:envoy.config.core.v3.Locality.sub_zone)
  return sub_zone_.GetNoArena();
}
inline void Locality::set_sub_zone(const std::string& value) {
  
  sub_zone_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:envoy.config.core.v3.Locality.sub_zone)
}
inline void Locality::set_sub_zone(std::string&& value) {
  
  sub_zone_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:envoy.config.core.v3.Locality.sub_zone)
}
inline void Locality::set_sub_zone(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  sub_zone_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:envoy.config.core.v3.Locality.sub_zone)
}
inline void Locality::set_sub_zone(const char* value, size_t size) {
  
  sub_zone_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:envoy.config.core.v3.Locality.sub_zone)
}
inline std::string* Locality::mutable_sub_zone() {
  
  // @@protoc_insertion_point(field_mutable:envoy.config.core.v3.Locality.sub_zone)
  return sub_zone_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Locality::release_sub_zone() {
  // @@protoc_insertion_point(field_release:envoy.config.core.v3.Locality.sub_zone)
  
  return sub_zone_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Locality::set_allocated_sub_zone(std::string* sub_zone) {
  if (sub_zone != nullptr) {
    
  } else {
    
  }
  sub_zone_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sub_zone);
  // @@protoc_insertion_point(field_set_allocated:envoy.config.core.v3.Locality.sub_zone)
}

// -------------------------------------------------------------------

// BuildVersion

// .envoy.type.v3.SemanticVersion version = 1;
inline bool BuildVersion::has_version() const {
  return this != internal_default_instance() && version_ != nullptr;
}
inline const ::envoy::type::v3::SemanticVersion& BuildVersion::version() const {
  const ::envoy::type::v3::SemanticVersion* p = version_;
  // @@protoc_insertion_point(field_get:envoy.config.core.v3.BuildVersion.version)
  return p != nullptr ? *p : *reinterpret_cast<const ::envoy::type::v3::SemanticVersion*>(
      &::envoy::type::v3::_SemanticVersion_default_instance_);
}
inline ::envoy::type::v3::SemanticVersion* BuildVersion::release_version() {
  // @@protoc_insertion_point(field_release:envoy.config.core.v3.BuildVersion.version)
  
  ::envoy::type::v3::SemanticVersion* temp = version_;
  version_ = nullptr;
  return temp;
}
inline ::envoy::type::v3::SemanticVersion* BuildVersion::mutable_version() {
  
  if (version_ == nullptr) {
    auto* p = CreateMaybeMessage<::envoy::type::v3::SemanticVersion>(GetArenaNoVirtual());
    version_ = p;
  }
  // @@protoc_insertion_point(field_mutable:envoy.config.core.v3.BuildVersion.version)
  return version_;
}
inline void BuildVersion::set_allocated_version(::envoy::type::v3::SemanticVersion* version) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(version_);
  }
  if (version) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      version = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, version, submessage_arena);
    }
    
  } else {
    
  }
  version_ = version;
  // @@protoc_insertion_point(field_set_allocated:envoy.config.core.v3.BuildVersion.version)
}

// .google.protobuf.Struct metadata = 2;
inline bool BuildVersion::has_metadata() const {
  return this != internal_default_instance() && metadata_ != nullptr;
}
inline const PROTOBUF_NAMESPACE_ID::Struct& BuildVersion::metadata() const {
  const PROTOBUF_NAMESPACE_ID::Struct* p = metadata_;
  // @@protoc_insertion_point(field_get:envoy.config.core.v3.BuildVersion.metadata)
  return p != nullptr ? *p : *reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Struct*>(
      &PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline PROTOBUF_NAMESPACE_ID::Struct* BuildVersion::release_metadata() {
  // @@protoc_insertion_point(field_release:envoy.config.core.v3.BuildVersion.metadata)
  
  PROTOBUF_NAMESPACE_ID::Struct* temp = metadata_;
  metadata_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Struct* BuildVersion::mutable_metadata() {
  
  if (metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Struct>(GetArenaNoVirtual());
    metadata_ = p;
  }
  // @@protoc_insertion_point(field_mutable:envoy.config.core.v3.BuildVersion.metadata)
  return metadata_;
}
inline void BuildVersion::set_allocated_metadata(PROTOBUF_NAMESPACE_ID::Struct* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata_);
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata)->GetArena();
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    
  } else {
    
  }
  metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:envoy.config.core.v3.BuildVersion.metadata)
}

// -------------------------------------------------------------------

// Extension

// string name = 1;
inline void Extension::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Extension::name() const {
  // @@protoc_insertion_point(field_get:envoy.config.core.v3.Extension.name)
  return name_.GetNoArena();
}
inline void Extension::set_name(const std::string& value) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:envoy.config.core.v3.Extension.name)
}
inline void Extension::set_name(std::string&& value) {
  
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:envoy.config.core.v3.Extension.name)
}
inline void Extension::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:envoy.config.core.v3.Extension.name)
}
inline void Extension::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:envoy.config.core.v3.Extension.name)
}
inline std::string* Extension::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:envoy.config.core.v3.Extension.name)
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Extension::release_name() {
  // @@protoc_insertion_point(field_release:envoy.config.core.v3.Extension.name)
  
  return name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Extension::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:envoy.config.core.v3.Extension.name)
}

// string category = 2;
inline void Extension::clear_category() {
  category_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Extension::category() const {
  // @@protoc_insertion_point(field_get:envoy.config.core.v3.Extension.category)
  return category_.GetNoArena();
}
inline void Extension::set_category(const std::string& value) {
  
  category_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:envoy.config.core.v3.Extension.category)
}
inline void Extension::set_category(std::string&& value) {
  
  category_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:envoy.config.core.v3.Extension.category)
}
inline void Extension::set_category(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  category_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:envoy.config.core.v3.Extension.category)
}
inline void Extension::set_category(const char* value, size_t size) {
  
  category_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:envoy.config.core.v3.Extension.category)
}
inline std::string* Extension::mutable_category() {
  
  // @@protoc_insertion_point(field_mutable:envoy.config.core.v3.Extension.category)
  return category_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Extension::release_category() {
  // @@protoc_insertion_point(field_release:envoy.config.core.v3.Extension.category)
  
  return category_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Extension::set_allocated_category(std::string* category) {
  if (category != nullptr) {
    
  } else {
    
  }
  category_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), category);
  // @@protoc_insertion_point(field_set_allocated:envoy.config.core.v3.Extension.category)
}

// string type_descriptor = 3;
inline void Extension::clear_type_descriptor() {
  type_descriptor_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Extension::type_descriptor() const {
  // @@protoc_insertion_point(field_get:envoy.config.core.v3.Extension.type_descriptor)
  return type_descriptor_.GetNoArena();
}
inline void Extension::set_type_descriptor(const std::string& value) {
  
  type_descriptor_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:envoy.config.core.v3.Extension.type_descriptor)
}
inline void Extension::set_type_descriptor(std::string&& value) {
  
  type_descriptor_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:envoy.config.core.v3.Extension.type_descriptor)
}
inline void Extension::set_type_descriptor(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  type_descriptor_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:envoy.config.core.v3.Extension.type_descriptor)
}
inline void Extension::set_type_descriptor(const char* value, size_t size) {
  
  type_descriptor_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:envoy.config.core.v3.Extension.type_descriptor)
}
inline std::string* Extension::mutable_type_descriptor() {
  
  // @@protoc_insertion_point(field_mutable:envoy.config.core.v3.Extension.type_descriptor)
  return type_descriptor_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Extension::release_type_descriptor() {
  // @@protoc_insertion_point(field_release:envoy.config.core.v3.Extension.type_descriptor)
  
  return type_descriptor_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Extension::set_allocated_type_descriptor(std::string* type_descriptor) {
  if (type_descriptor != nullptr) {
    
  } else {
    
  }
  type_descriptor_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), type_descriptor);
  // @@protoc_insertion_point(field_set_allocated:envoy.config.core.v3.Extension.type_descriptor)
}

// .envoy.config.core.v3.BuildVersion version = 4;
inline bool Extension::has_version() const {
  return this != internal_default_instance() && version_ != nullptr;
}
inline void Extension::clear_version() {
  if (GetArenaNoVirtual() == nullptr && version_ != nullptr) {
    delete version_;
  }
  version_ = nullptr;
}
inline const ::envoy::config::core::v3::BuildVersion& Extension::version() const {
  const ::envoy::config::core::v3::BuildVersion* p = version_;
  // @@protoc_insertion_point(field_get:envoy.config.core.v3.Extension.version)
  return p != nullptr ? *p : *reinterpret_cast<const ::envoy::config::core::v3::BuildVersion*>(
      &::envoy::config::core::v3::_BuildVersion_default_instance_);
}
inline ::envoy::config::core::v3::BuildVersion* Extension::release_version() {
  // @@protoc_insertion_point(field_release:envoy.config.core.v3.Extension.version)
  
  ::envoy::config::core::v3::BuildVersion* temp = version_;
  version_ = nullptr;
  return temp;
}
inline ::envoy::config::core::v3::BuildVersion* Extension::mutable_version() {
  
  if (version_ == nullptr) {
    auto* p = CreateMaybeMessage<::envoy::config::core::v3::BuildVersion>(GetArenaNoVirtual());
    version_ = p;
  }
  // @@protoc_insertion_point(field_mutable:envoy.config.core.v3.Extension.version)
  return version_;
}
inline void Extension::set_allocated_version(::envoy::config::core::v3::BuildVersion* version) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete version_;
  }
  if (version) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      version = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, version, submessage_arena);
    }
    
  } else {
    
  }
  version_ = version;
  // @@protoc_insertion_point(field_set_allocated:envoy.config.core.v3.Extension.version)
}

// bool disabled = 5;
inline void Extension::clear_disabled() {
  disabled_ = false;
}
inline bool Extension::disabled() const {
  // @@protoc_insertion_point(field_get:envoy.config.core.v3.Extension.disabled)
  return disabled_;
}
inline void Extension::set_disabled(bool value) {
  
  disabled_ = value;
  // @@protoc_insertion_point(field_set:envoy.config.core.v3.Extension.disabled)
}

// -------------------------------------------------------------------

// Node

// string id = 1;
inline void Node::clear_id() {
  id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Node::id() const {
  // @@protoc_insertion_point(field_get:envoy.config.core.v3.Node.id)
  return id_.GetNoArena();
}
inline void Node::set_id(const std::string& value) {
  
  id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:envoy.config.core.v3.Node.id)
}
inline void Node::set_id(std::string&& value) {
  
  id_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:envoy.config.core.v3.Node.id)
}
inline void Node::set_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:envoy.config.core.v3.Node.id)
}
inline void Node::set_id(const char* value, size_t size) {
  
  id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:envoy.config.core.v3.Node.id)
}
inline std::string* Node::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:envoy.config.core.v3.Node.id)
  return id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Node::release_id() {
  // @@protoc_insertion_point(field_release:envoy.config.core.v3.Node.id)
  
  return id_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Node::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:envoy.config.core.v3.Node.id)
}

// string cluster = 2;
inline void Node::clear_cluster() {
  cluster_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Node::cluster() const {
  // @@protoc_insertion_point(field_get:envoy.config.core.v3.Node.cluster)
  return cluster_.GetNoArena();
}
inline void Node::set_cluster(const std::string& value) {
  
  cluster_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:envoy.config.core.v3.Node.cluster)
}
inline void Node::set_cluster(std::string&& value) {
  
  cluster_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:envoy.config.core.v3.Node.cluster)
}
inline void Node::set_cluster(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  cluster_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:envoy.config.core.v3.Node.cluster)
}
inline void Node::set_cluster(const char* value, size_t size) {
  
  cluster_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:envoy.config.core.v3.Node.cluster)
}
inline std::string* Node::mutable_cluster() {
  
  // @@protoc_insertion_point(field_mutable:envoy.config.core.v3.Node.cluster)
  return cluster_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Node::release_cluster() {
  // @@protoc_insertion_point(field_release:envoy.config.core.v3.Node.cluster)
  
  return cluster_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Node::set_allocated_cluster(std::string* cluster) {
  if (cluster != nullptr) {
    
  } else {
    
  }
  cluster_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), cluster);
  // @@protoc_insertion_point(field_set_allocated:envoy.config.core.v3.Node.cluster)
}

// .google.protobuf.Struct metadata = 3;
inline bool Node::has_metadata() const {
  return this != internal_default_instance() && metadata_ != nullptr;
}
inline const PROTOBUF_NAMESPACE_ID::Struct& Node::metadata() const {
  const PROTOBUF_NAMESPACE_ID::Struct* p = metadata_;
  // @@protoc_insertion_point(field_get:envoy.config.core.v3.Node.metadata)
  return p != nullptr ? *p : *reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Struct*>(
      &PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline PROTOBUF_NAMESPACE_ID::Struct* Node::release_metadata() {
  // @@protoc_insertion_point(field_release:envoy.config.core.v3.Node.metadata)
  
  PROTOBUF_NAMESPACE_ID::Struct* temp = metadata_;
  metadata_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Struct* Node::mutable_metadata() {
  
  if (metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Struct>(GetArenaNoVirtual());
    metadata_ = p;
  }
  // @@protoc_insertion_point(field_mutable:envoy.config.core.v3.Node.metadata)
  return metadata_;
}
inline void Node::set_allocated_metadata(PROTOBUF_NAMESPACE_ID::Struct* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata_);
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata)->GetArena();
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    
  } else {
    
  }
  metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:envoy.config.core.v3.Node.metadata)
}

// .envoy.config.core.v3.Locality locality = 4;
inline bool Node::has_locality() const {
  return this != internal_default_instance() && locality_ != nullptr;
}
inline void Node::clear_locality() {
  if (GetArenaNoVirtual() == nullptr && locality_ != nullptr) {
    delete locality_;
  }
  locality_ = nullptr;
}
inline const ::envoy::config::core::v3::Locality& Node::locality() const {
  const ::envoy::config::core::v3::Locality* p = locality_;
  // @@protoc_insertion_point(field_get:envoy.config.core.v3.Node.locality)
  return p != nullptr ? *p : *reinterpret_cast<const ::envoy::config::core::v3::Locality*>(
      &::envoy::config::core::v3::_Locality_default_instance_);
}
inline ::envoy::config::core::v3::Locality* Node::release_locality() {
  // @@protoc_insertion_point(field_release:envoy.config.core.v3.Node.locality)
  
  ::envoy::config::core::v3::Locality* temp = locality_;
  locality_ = nullptr;
  return temp;
}
inline ::envoy::config::core::v3::Locality* Node::mutable_locality() {
  
  if (locality_ == nullptr) {
    auto* p = CreateMaybeMessage<::envoy::config::core::v3::Locality>(GetArenaNoVirtual());
    locality_ = p;
  }
  // @@protoc_insertion_point(field_mutable:envoy.config.core.v3.Node.locality)
  return locality_;
}
inline void Node::set_allocated_locality(::envoy::config::core::v3::Locality* locality) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete locality_;
  }
  if (locality) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      locality = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, locality, submessage_arena);
    }
    
  } else {
    
  }
  locality_ = locality;
  // @@protoc_insertion_point(field_set_allocated:envoy.config.core.v3.Node.locality)
}

// string user_agent_name = 6;
inline void Node::clear_user_agent_name() {
  user_agent_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Node::user_agent_name() const {
  // @@protoc_insertion_point(field_get:envoy.config.core.v3.Node.user_agent_name)
  return user_agent_name_.GetNoArena();
}
inline void Node::set_user_agent_name(const std::string& value) {
  
  user_agent_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:envoy.config.core.v3.Node.user_agent_name)
}
inline void Node::set_user_agent_name(std::string&& value) {
  
  user_agent_name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:envoy.config.core.v3.Node.user_agent_name)
}
inline void Node::set_user_agent_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  user_agent_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:envoy.config.core.v3.Node.user_agent_name)
}
inline void Node::set_user_agent_name(const char* value, size_t size) {
  
  user_agent_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:envoy.config.core.v3.Node.user_agent_name)
}
inline std::string* Node::mutable_user_agent_name() {
  
  // @@protoc_insertion_point(field_mutable:envoy.config.core.v3.Node.user_agent_name)
  return user_agent_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Node::release_user_agent_name() {
  // @@protoc_insertion_point(field_release:envoy.config.core.v3.Node.user_agent_name)
  
  return user_agent_name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Node::set_allocated_user_agent_name(std::string* user_agent_name) {
  if (user_agent_name != nullptr) {
    
  } else {
    
  }
  user_agent_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user_agent_name);
  // @@protoc_insertion_point(field_set_allocated:envoy.config.core.v3.Node.user_agent_name)
}

// string user_agent_version = 7;
inline bool Node::has_user_agent_version() const {
  return user_agent_version_type_case() == kUserAgentVersion;
}
inline void Node::set_has_user_agent_version() {
  _oneof_case_[0] = kUserAgentVersion;
}
inline void Node::clear_user_agent_version() {
  if (has_user_agent_version()) {
    user_agent_version_type_.user_agent_version_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
    clear_has_user_agent_version_type();
  }
}
inline const std::string& Node::user_agent_version() const {
  // @@protoc_insertion_point(field_get:envoy.config.core.v3.Node.user_agent_version)
  if (has_user_agent_version()) {
    return user_agent_version_type_.user_agent_version_.GetNoArena();
  }
  return *&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void Node::set_user_agent_version(const std::string& value) {
  // @@protoc_insertion_point(field_set:envoy.config.core.v3.Node.user_agent_version)
  if (!has_user_agent_version()) {
    clear_user_agent_version_type();
    set_has_user_agent_version();
    user_agent_version_type_.user_agent_version_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  user_agent_version_type_.user_agent_version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:envoy.config.core.v3.Node.user_agent_version)
}
inline void Node::set_user_agent_version(std::string&& value) {
  // @@protoc_insertion_point(field_set:envoy.config.core.v3.Node.user_agent_version)
  if (!has_user_agent_version()) {
    clear_user_agent_version_type();
    set_has_user_agent_version();
    user_agent_version_type_.user_agent_version_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  user_agent_version_type_.user_agent_version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:envoy.config.core.v3.Node.user_agent_version)
}
inline void Node::set_user_agent_version(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  if (!has_user_agent_version()) {
    clear_user_agent_version_type();
    set_has_user_agent_version();
    user_agent_version_type_.user_agent_version_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  user_agent_version_type_.user_agent_version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:envoy.config.core.v3.Node.user_agent_version)
}
inline void Node::set_user_agent_version(const char* value, size_t size) {
  if (!has_user_agent_version()) {
    clear_user_agent_version_type();
    set_has_user_agent_version();
    user_agent_version_type_.user_agent_version_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  user_agent_version_type_.user_agent_version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:envoy.config.core.v3.Node.user_agent_version)
}
inline std::string* Node::mutable_user_agent_version() {
  if (!has_user_agent_version()) {
    clear_user_agent_version_type();
    set_has_user_agent_version();
    user_agent_version_type_.user_agent_version_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:envoy.config.core.v3.Node.user_agent_version)
  return user_agent_version_type_.user_agent_version_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Node::release_user_agent_version() {
  // @@protoc_insertion_point(field_release:envoy.config.core.v3.Node.user_agent_version)
  if (has_user_agent_version()) {
    clear_has_user_agent_version_type();
    return user_agent_version_type_.user_agent_version_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  } else {
    return nullptr;
  }
}
inline void Node::set_allocated_user_agent_version(std::string* user_agent_version) {
  if (has_user_agent_version_type()) {
    clear_user_agent_version_type();
  }
  if (user_agent_version != nullptr) {
    set_has_user_agent_version();
    user_agent_version_type_.user_agent_version_.UnsafeSetDefault(user_agent_version);
  }
  // @@protoc_insertion_point(field_set_allocated:envoy.config.core.v3.Node.user_agent_version)
}

// .envoy.config.core.v3.BuildVersion user_agent_build_version = 8;
inline bool Node::has_user_agent_build_version() const {
  return user_agent_version_type_case() == kUserAgentBuildVersion;
}
inline void Node::set_has_user_agent_build_version() {
  _oneof_case_[0] = kUserAgentBuildVersion;
}
inline void Node::clear_user_agent_build_version() {
  if (has_user_agent_build_version()) {
    delete user_agent_version_type_.user_agent_build_version_;
    clear_has_user_agent_version_type();
  }
}
inline ::envoy::config::core::v3::BuildVersion* Node::release_user_agent_build_version() {
  // @@protoc_insertion_point(field_release:envoy.config.core.v3.Node.user_agent_build_version)
  if (has_user_agent_build_version()) {
    clear_has_user_agent_version_type();
      ::envoy::config::core::v3::BuildVersion* temp = user_agent_version_type_.user_agent_build_version_;
    user_agent_version_type_.user_agent_build_version_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::envoy::config::core::v3::BuildVersion& Node::user_agent_build_version() const {
  // @@protoc_insertion_point(field_get:envoy.config.core.v3.Node.user_agent_build_version)
  return has_user_agent_build_version()
      ? *user_agent_version_type_.user_agent_build_version_
      : *reinterpret_cast< ::envoy::config::core::v3::BuildVersion*>(&::envoy::config::core::v3::_BuildVersion_default_instance_);
}
inline ::envoy::config::core::v3::BuildVersion* Node::mutable_user_agent_build_version() {
  if (!has_user_agent_build_version()) {
    clear_user_agent_version_type();
    set_has_user_agent_build_version();
    user_agent_version_type_.user_agent_build_version_ = CreateMaybeMessage< ::envoy::config::core::v3::BuildVersion >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:envoy.config.core.v3.Node.user_agent_build_version)
  return user_agent_version_type_.user_agent_build_version_;
}

// repeated .envoy.config.core.v3.Extension extensions = 9;
inline int Node::extensions_size() const {
  return extensions_.size();
}
inline void Node::clear_extensions() {
  extensions_.Clear();
}
inline ::envoy::config::core::v3::Extension* Node::mutable_extensions(int index) {
  // @@protoc_insertion_point(field_mutable:envoy.config.core.v3.Node.extensions)
  return extensions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::envoy::config::core::v3::Extension >*
Node::mutable_extensions() {
  // @@protoc_insertion_point(field_mutable_list:envoy.config.core.v3.Node.extensions)
  return &extensions_;
}
inline const ::envoy::config::core::v3::Extension& Node::extensions(int index) const {
  // @@protoc_insertion_point(field_get:envoy.config.core.v3.Node.extensions)
  return extensions_.Get(index);
}
inline ::envoy::config::core::v3::Extension* Node::add_extensions() {
  // @@protoc_insertion_point(field_add:envoy.config.core.v3.Node.extensions)
  return extensions_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::envoy::config::core::v3::Extension >&
Node::extensions() const {
  // @@protoc_insertion_point(field_list:envoy.config.core.v3.Node.extensions)
  return extensions_;
}

// repeated string client_features = 10;
inline int Node::client_features_size() const {
  return client_features_.size();
}
inline void Node::clear_client_features() {
  client_features_.Clear();
}
inline const std::string& Node::client_features(int index) const {
  // @@protoc_insertion_point(field_get:envoy.config.core.v3.Node.client_features)
  return client_features_.Get(index);
}
inline std::string* Node::mutable_client_features(int index) {
  // @@protoc_insertion_point(field_mutable:envoy.config.core.v3.Node.client_features)
  return client_features_.Mutable(index);
}
inline void Node::set_client_features(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:envoy.config.core.v3.Node.client_features)
  client_features_.Mutable(index)->assign(value);
}
inline void Node::set_client_features(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:envoy.config.core.v3.Node.client_features)
  client_features_.Mutable(index)->assign(std::move(value));
}
inline void Node::set_client_features(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  client_features_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:envoy.config.core.v3.Node.client_features)
}
inline void Node::set_client_features(int index, const char* value, size_t size) {
  client_features_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:envoy.config.core.v3.Node.client_features)
}
inline std::string* Node::add_client_features() {
  // @@protoc_insertion_point(field_add_mutable:envoy.config.core.v3.Node.client_features)
  return client_features_.Add();
}
inline void Node::add_client_features(const std::string& value) {
  client_features_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:envoy.config.core.v3.Node.client_features)
}
inline void Node::add_client_features(std::string&& value) {
  client_features_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:envoy.config.core.v3.Node.client_features)
}
inline void Node::add_client_features(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  client_features_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:envoy.config.core.v3.Node.client_features)
}
inline void Node::add_client_features(const char* value, size_t size) {
  client_features_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:envoy.config.core.v3.Node.client_features)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Node::client_features() const {
  // @@protoc_insertion_point(field_list:envoy.config.core.v3.Node.client_features)
  return client_features_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Node::mutable_client_features() {
  // @@protoc_insertion_point(field_mutable_list:envoy.config.core.v3.Node.client_features)
  return &client_features_;
}

// repeated .envoy.config.core.v3.Address listening_addresses = 11;
inline int Node::listening_addresses_size() const {
  return listening_addresses_.size();
}
inline ::envoy::config::core::v3::Address* Node::mutable_listening_addresses(int index) {
  // @@protoc_insertion_point(field_mutable:envoy.config.core.v3.Node.listening_addresses)
  return listening_addresses_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::envoy::config::core::v3::Address >*
Node::mutable_listening_addresses() {
  // @@protoc_insertion_point(field_mutable_list:envoy.config.core.v3.Node.listening_addresses)
  return &listening_addresses_;
}
inline const ::envoy::config::core::v3::Address& Node::listening_addresses(int index) const {
  // @@protoc_insertion_point(field_get:envoy.config.core.v3.Node.listening_addresses)
  return listening_addresses_.Get(index);
}
inline ::envoy::config::core::v3::Address* Node::add_listening_addresses() {
  // @@protoc_insertion_point(field_add:envoy.config.core.v3.Node.listening_addresses)
  return listening_addresses_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::envoy::config::core::v3::Address >&
Node::listening_addresses() const {
  // @@protoc_insertion_point(field_list:envoy.config.core.v3.Node.listening_addresses)
  return listening_addresses_;
}

inline bool Node::has_user_agent_version_type() const {
  return user_agent_version_type_case() != USER_AGENT_VERSION_TYPE_NOT_SET;
}
inline void Node::clear_has_user_agent_version_type() {
  _oneof_case_[0] = USER_AGENT_VERSION_TYPE_NOT_SET;
}
inline Node::UserAgentVersionTypeCase Node::user_agent_version_type_case() const {
  return Node::UserAgentVersionTypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Metadata

// map<string, .google.protobuf.Struct> filter_metadata = 1;
inline int Metadata::filter_metadata_size() const {
  return filter_metadata_.size();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, PROTOBUF_NAMESPACE_ID::Struct >&
Metadata::filter_metadata() const {
  // @@protoc_insertion_point(field_map:envoy.config.core.v3.Metadata.filter_metadata)
  return filter_metadata_.GetMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, PROTOBUF_NAMESPACE_ID::Struct >*
Metadata::mutable_filter_metadata() {
  // @@protoc_insertion_point(field_mutable_map:envoy.config.core.v3.Metadata.filter_metadata)
  return filter_metadata_.MutableMap();
}

// -------------------------------------------------------------------

// RuntimeUInt32

// uint32 default_value = 2;
inline void RuntimeUInt32::clear_default_value() {
  default_value_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 RuntimeUInt32::default_value() const {
  // @@protoc_insertion_point(field_get:envoy.config.core.v3.RuntimeUInt32.default_value)
  return default_value_;
}
inline void RuntimeUInt32::set_default_value(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  default_value_ = value;
  // @@protoc_insertion_point(field_set:envoy.config.core.v3.RuntimeUInt32.default_value)
}

// string runtime_key = 3 [(.validate.rules) = {
inline void RuntimeUInt32::clear_runtime_key() {
  runtime_key_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& RuntimeUInt32::runtime_key() const {
  // @@protoc_insertion_point(field_get:envoy.config.core.v3.RuntimeUInt32.runtime_key)
  return runtime_key_.GetNoArena();
}
inline void RuntimeUInt32::set_runtime_key(const std::string& value) {
  
  runtime_key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:envoy.config.core.v3.RuntimeUInt32.runtime_key)
}
inline void RuntimeUInt32::set_runtime_key(std::string&& value) {
  
  runtime_key_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:envoy.config.core.v3.RuntimeUInt32.runtime_key)
}
inline void RuntimeUInt32::set_runtime_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  runtime_key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:envoy.config.core.v3.RuntimeUInt32.runtime_key)
}
inline void RuntimeUInt32::set_runtime_key(const char* value, size_t size) {
  
  runtime_key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:envoy.config.core.v3.RuntimeUInt32.runtime_key)
}
inline std::string* RuntimeUInt32::mutable_runtime_key() {
  
  // @@protoc_insertion_point(field_mutable:envoy.config.core.v3.RuntimeUInt32.runtime_key)
  return runtime_key_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* RuntimeUInt32::release_runtime_key() {
  // @@protoc_insertion_point(field_release:envoy.config.core.v3.RuntimeUInt32.runtime_key)
  
  return runtime_key_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void RuntimeUInt32::set_allocated_runtime_key(std::string* runtime_key) {
  if (runtime_key != nullptr) {
    
  } else {
    
  }
  runtime_key_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), runtime_key);
  // @@protoc_insertion_point(field_set_allocated:envoy.config.core.v3.RuntimeUInt32.runtime_key)
}

// -------------------------------------------------------------------

// RuntimeFeatureFlag

// .google.protobuf.BoolValue default_value = 1 [(.validate.rules) = {
inline bool RuntimeFeatureFlag::has_default_value() const {
  return this != internal_default_instance() && default_value_ != nullptr;
}
inline const PROTOBUF_NAMESPACE_ID::BoolValue& RuntimeFeatureFlag::default_value() const {
  const PROTOBUF_NAMESPACE_ID::BoolValue* p = default_value_;
  // @@protoc_insertion_point(field_get:envoy.config.core.v3.RuntimeFeatureFlag.default_value)
  return p != nullptr ? *p : *reinterpret_cast<const PROTOBUF_NAMESPACE_ID::BoolValue*>(
      &PROTOBUF_NAMESPACE_ID::_BoolValue_default_instance_);
}
inline PROTOBUF_NAMESPACE_ID::BoolValue* RuntimeFeatureFlag::release_default_value() {
  // @@protoc_insertion_point(field_release:envoy.config.core.v3.RuntimeFeatureFlag.default_value)
  
  PROTOBUF_NAMESPACE_ID::BoolValue* temp = default_value_;
  default_value_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::BoolValue* RuntimeFeatureFlag::mutable_default_value() {
  
  if (default_value_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::BoolValue>(GetArenaNoVirtual());
    default_value_ = p;
  }
  // @@protoc_insertion_point(field_mutable:envoy.config.core.v3.RuntimeFeatureFlag.default_value)
  return default_value_;
}
inline void RuntimeFeatureFlag::set_allocated_default_value(PROTOBUF_NAMESPACE_ID::BoolValue* default_value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(default_value_);
  }
  if (default_value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(default_value)->GetArena();
    if (message_arena != submessage_arena) {
      default_value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, default_value, submessage_arena);
    }
    
  } else {
    
  }
  default_value_ = default_value;
  // @@protoc_insertion_point(field_set_allocated:envoy.config.core.v3.RuntimeFeatureFlag.default_value)
}

// string runtime_key = 2 [(.validate.rules) = {
inline void RuntimeFeatureFlag::clear_runtime_key() {
  runtime_key_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& RuntimeFeatureFlag::runtime_key() const {
  // @@protoc_insertion_point(field_get:envoy.config.core.v3.RuntimeFeatureFlag.runtime_key)
  return runtime_key_.GetNoArena();
}
inline void RuntimeFeatureFlag::set_runtime_key(const std::string& value) {
  
  runtime_key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:envoy.config.core.v3.RuntimeFeatureFlag.runtime_key)
}
inline void RuntimeFeatureFlag::set_runtime_key(std::string&& value) {
  
  runtime_key_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:envoy.config.core.v3.RuntimeFeatureFlag.runtime_key)
}
inline void RuntimeFeatureFlag::set_runtime_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  runtime_key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:envoy.config.core.v3.RuntimeFeatureFlag.runtime_key)
}
inline void RuntimeFeatureFlag::set_runtime_key(const char* value, size_t size) {
  
  runtime_key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:envoy.config.core.v3.RuntimeFeatureFlag.runtime_key)
}
inline std::string* RuntimeFeatureFlag::mutable_runtime_key() {
  
  // @@protoc_insertion_point(field_mutable:envoy.config.core.v3.RuntimeFeatureFlag.runtime_key)
  return runtime_key_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* RuntimeFeatureFlag::release_runtime_key() {
  // @@protoc_insertion_point(field_release:envoy.config.core.v3.RuntimeFeatureFlag.runtime_key)
  
  return runtime_key_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void RuntimeFeatureFlag::set_allocated_runtime_key(std::string* runtime_key) {
  if (runtime_key != nullptr) {
    
  } else {
    
  }
  runtime_key_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), runtime_key);
  // @@protoc_insertion_point(field_set_allocated:envoy.config.core.v3.RuntimeFeatureFlag.runtime_key)
}

// -------------------------------------------------------------------

// HeaderValue

// string key = 1 [(.validate.rules) = {
inline void HeaderValue::clear_key() {
  key_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& HeaderValue::key() const {
  // @@protoc_insertion_point(field_get:envoy.config.core.v3.HeaderValue.key)
  return key_.GetNoArena();
}
inline void HeaderValue::set_key(const std::string& value) {
  
  key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:envoy.config.core.v3.HeaderValue.key)
}
inline void HeaderValue::set_key(std::string&& value) {
  
  key_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:envoy.config.core.v3.HeaderValue.key)
}
inline void HeaderValue::set_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:envoy.config.core.v3.HeaderValue.key)
}
inline void HeaderValue::set_key(const char* value, size_t size) {
  
  key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:envoy.config.core.v3.HeaderValue.key)
}
inline std::string* HeaderValue::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:envoy.config.core.v3.HeaderValue.key)
  return key_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* HeaderValue::release_key() {
  // @@protoc_insertion_point(field_release:envoy.config.core.v3.HeaderValue.key)
  
  return key_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void HeaderValue::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:envoy.config.core.v3.HeaderValue.key)
}

// string value = 2 [(.validate.rules) = {
inline void HeaderValue::clear_value() {
  value_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& HeaderValue::value() const {
  // @@protoc_insertion_point(field_get:envoy.config.core.v3.HeaderValue.value)
  return value_.GetNoArena();
}
inline void HeaderValue::set_value(const std::string& value) {
  
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:envoy.config.core.v3.HeaderValue.value)
}
inline void HeaderValue::set_value(std::string&& value) {
  
  value_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:envoy.config.core.v3.HeaderValue.value)
}
inline void HeaderValue::set_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:envoy.config.core.v3.HeaderValue.value)
}
inline void HeaderValue::set_value(const char* value, size_t size) {
  
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:envoy.config.core.v3.HeaderValue.value)
}
inline std::string* HeaderValue::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:envoy.config.core.v3.HeaderValue.value)
  return value_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* HeaderValue::release_value() {
  // @@protoc_insertion_point(field_release:envoy.config.core.v3.HeaderValue.value)
  
  return value_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void HeaderValue::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:envoy.config.core.v3.HeaderValue.value)
}

// -------------------------------------------------------------------

// HeaderValueOption

// .envoy.config.core.v3.HeaderValue header = 1 [(.validate.rules) = {
inline bool HeaderValueOption::has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline void HeaderValueOption::clear_header() {
  if (GetArenaNoVirtual() == nullptr && header_ != nullptr) {
    delete header_;
  }
  header_ = nullptr;
}
inline const ::envoy::config::core::v3::HeaderValue& HeaderValueOption::header() const {
  const ::envoy::config::core::v3::HeaderValue* p = header_;
  // @@protoc_insertion_point(field_get:envoy.config.core.v3.HeaderValueOption.header)
  return p != nullptr ? *p : *reinterpret_cast<const ::envoy::config::core::v3::HeaderValue*>(
      &::envoy::config::core::v3::_HeaderValue_default_instance_);
}
inline ::envoy::config::core::v3::HeaderValue* HeaderValueOption::release_header() {
  // @@protoc_insertion_point(field_release:envoy.config.core.v3.HeaderValueOption.header)
  
  ::envoy::config::core::v3::HeaderValue* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::envoy::config::core::v3::HeaderValue* HeaderValueOption::mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::envoy::config::core::v3::HeaderValue>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:envoy.config.core.v3.HeaderValueOption.header)
  return header_;
}
inline void HeaderValueOption::set_allocated_header(::envoy::config::core::v3::HeaderValue* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:envoy.config.core.v3.HeaderValueOption.header)
}

// .google.protobuf.BoolValue append = 2;
inline bool HeaderValueOption::has_append() const {
  return this != internal_default_instance() && append_ != nullptr;
}
inline const PROTOBUF_NAMESPACE_ID::BoolValue& HeaderValueOption::append() const {
  const PROTOBUF_NAMESPACE_ID::BoolValue* p = append_;
  // @@protoc_insertion_point(field_get:envoy.config.core.v3.HeaderValueOption.append)
  return p != nullptr ? *p : *reinterpret_cast<const PROTOBUF_NAMESPACE_ID::BoolValue*>(
      &PROTOBUF_NAMESPACE_ID::_BoolValue_default_instance_);
}
inline PROTOBUF_NAMESPACE_ID::BoolValue* HeaderValueOption::release_append() {
  // @@protoc_insertion_point(field_release:envoy.config.core.v3.HeaderValueOption.append)
  
  PROTOBUF_NAMESPACE_ID::BoolValue* temp = append_;
  append_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::BoolValue* HeaderValueOption::mutable_append() {
  
  if (append_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::BoolValue>(GetArenaNoVirtual());
    append_ = p;
  }
  // @@protoc_insertion_point(field_mutable:envoy.config.core.v3.HeaderValueOption.append)
  return append_;
}
inline void HeaderValueOption::set_allocated_append(PROTOBUF_NAMESPACE_ID::BoolValue* append) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(append_);
  }
  if (append) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(append)->GetArena();
    if (message_arena != submessage_arena) {
      append = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, append, submessage_arena);
    }
    
  } else {
    
  }
  append_ = append;
  // @@protoc_insertion_point(field_set_allocated:envoy.config.core.v3.HeaderValueOption.append)
}

// -------------------------------------------------------------------

// HeaderMap

// repeated .envoy.config.core.v3.HeaderValue headers = 1;
inline int HeaderMap::headers_size() const {
  return headers_.size();
}
inline void HeaderMap::clear_headers() {
  headers_.Clear();
}
inline ::envoy::config::core::v3::HeaderValue* HeaderMap::mutable_headers(int index) {
  // @@protoc_insertion_point(field_mutable:envoy.config.core.v3.HeaderMap.headers)
  return headers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::envoy::config::core::v3::HeaderValue >*
HeaderMap::mutable_headers() {
  // @@protoc_insertion_point(field_mutable_list:envoy.config.core.v3.HeaderMap.headers)
  return &headers_;
}
inline const ::envoy::config::core::v3::HeaderValue& HeaderMap::headers(int index) const {
  // @@protoc_insertion_point(field_get:envoy.config.core.v3.HeaderMap.headers)
  return headers_.Get(index);
}
inline ::envoy::config::core::v3::HeaderValue* HeaderMap::add_headers() {
  // @@protoc_insertion_point(field_add:envoy.config.core.v3.HeaderMap.headers)
  return headers_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::envoy::config::core::v3::HeaderValue >&
HeaderMap::headers() const {
  // @@protoc_insertion_point(field_list:envoy.config.core.v3.HeaderMap.headers)
  return headers_;
}

// -------------------------------------------------------------------

// DataSource

// string filename = 1 [(.validate.rules) = {
inline bool DataSource::has_filename() const {
  return specifier_case() == kFilename;
}
inline void DataSource::set_has_filename() {
  _oneof_case_[0] = kFilename;
}
inline void DataSource::clear_filename() {
  if (has_filename()) {
    specifier_.filename_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
    clear_has_specifier();
  }
}
inline const std::string& DataSource::filename() const {
  // @@protoc_insertion_point(field_get:envoy.config.core.v3.DataSource.filename)
  if (has_filename()) {
    return specifier_.filename_.GetNoArena();
  }
  return *&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void DataSource::set_filename(const std::string& value) {
  // @@protoc_insertion_point(field_set:envoy.config.core.v3.DataSource.filename)
  if (!has_filename()) {
    clear_specifier();
    set_has_filename();
    specifier_.filename_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  specifier_.filename_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:envoy.config.core.v3.DataSource.filename)
}
inline void DataSource::set_filename(std::string&& value) {
  // @@protoc_insertion_point(field_set:envoy.config.core.v3.DataSource.filename)
  if (!has_filename()) {
    clear_specifier();
    set_has_filename();
    specifier_.filename_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  specifier_.filename_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:envoy.config.core.v3.DataSource.filename)
}
inline void DataSource::set_filename(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  if (!has_filename()) {
    clear_specifier();
    set_has_filename();
    specifier_.filename_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  specifier_.filename_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:envoy.config.core.v3.DataSource.filename)
}
inline void DataSource::set_filename(const char* value, size_t size) {
  if (!has_filename()) {
    clear_specifier();
    set_has_filename();
    specifier_.filename_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  specifier_.filename_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:envoy.config.core.v3.DataSource.filename)
}
inline std::string* DataSource::mutable_filename() {
  if (!has_filename()) {
    clear_specifier();
    set_has_filename();
    specifier_.filename_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:envoy.config.core.v3.DataSource.filename)
  return specifier_.filename_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DataSource::release_filename() {
  // @@protoc_insertion_point(field_release:envoy.config.core.v3.DataSource.filename)
  if (has_filename()) {
    clear_has_specifier();
    return specifier_.filename_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  } else {
    return nullptr;
  }
}
inline void DataSource::set_allocated_filename(std::string* filename) {
  if (has_specifier()) {
    clear_specifier();
  }
  if (filename != nullptr) {
    set_has_filename();
    specifier_.filename_.UnsafeSetDefault(filename);
  }
  // @@protoc_insertion_point(field_set_allocated:envoy.config.core.v3.DataSource.filename)
}

// bytes inline_bytes = 2 [(.validate.rules) = {
inline bool DataSource::has_inline_bytes() const {
  return specifier_case() == kInlineBytes;
}
inline void DataSource::set_has_inline_bytes() {
  _oneof_case_[0] = kInlineBytes;
}
inline void DataSource::clear_inline_bytes() {
  if (has_inline_bytes()) {
    specifier_.inline_bytes_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
    clear_has_specifier();
  }
}
inline const std::string& DataSource::inline_bytes() const {
  // @@protoc_insertion_point(field_get:envoy.config.core.v3.DataSource.inline_bytes)
  if (has_inline_bytes()) {
    return specifier_.inline_bytes_.GetNoArena();
  }
  return *&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void DataSource::set_inline_bytes(const std::string& value) {
  // @@protoc_insertion_point(field_set:envoy.config.core.v3.DataSource.inline_bytes)
  if (!has_inline_bytes()) {
    clear_specifier();
    set_has_inline_bytes();
    specifier_.inline_bytes_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  specifier_.inline_bytes_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:envoy.config.core.v3.DataSource.inline_bytes)
}
inline void DataSource::set_inline_bytes(std::string&& value) {
  // @@protoc_insertion_point(field_set:envoy.config.core.v3.DataSource.inline_bytes)
  if (!has_inline_bytes()) {
    clear_specifier();
    set_has_inline_bytes();
    specifier_.inline_bytes_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  specifier_.inline_bytes_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:envoy.config.core.v3.DataSource.inline_bytes)
}
inline void DataSource::set_inline_bytes(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  if (!has_inline_bytes()) {
    clear_specifier();
    set_has_inline_bytes();
    specifier_.inline_bytes_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  specifier_.inline_bytes_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:envoy.config.core.v3.DataSource.inline_bytes)
}
inline void DataSource::set_inline_bytes(const void* value, size_t size) {
  if (!has_inline_bytes()) {
    clear_specifier();
    set_has_inline_bytes();
    specifier_.inline_bytes_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  specifier_.inline_bytes_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:envoy.config.core.v3.DataSource.inline_bytes)
}
inline std::string* DataSource::mutable_inline_bytes() {
  if (!has_inline_bytes()) {
    clear_specifier();
    set_has_inline_bytes();
    specifier_.inline_bytes_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:envoy.config.core.v3.DataSource.inline_bytes)
  return specifier_.inline_bytes_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DataSource::release_inline_bytes() {
  // @@protoc_insertion_point(field_release:envoy.config.core.v3.DataSource.inline_bytes)
  if (has_inline_bytes()) {
    clear_has_specifier();
    return specifier_.inline_bytes_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  } else {
    return nullptr;
  }
}
inline void DataSource::set_allocated_inline_bytes(std::string* inline_bytes) {
  if (has_specifier()) {
    clear_specifier();
  }
  if (inline_bytes != nullptr) {
    set_has_inline_bytes();
    specifier_.inline_bytes_.UnsafeSetDefault(inline_bytes);
  }
  // @@protoc_insertion_point(field_set_allocated:envoy.config.core.v3.DataSource.inline_bytes)
}

// string inline_string = 3 [(.validate.rules) = {
inline bool DataSource::has_inline_string() const {
  return specifier_case() == kInlineString;
}
inline void DataSource::set_has_inline_string() {
  _oneof_case_[0] = kInlineString;
}
inline void DataSource::clear_inline_string() {
  if (has_inline_string()) {
    specifier_.inline_string_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
    clear_has_specifier();
  }
}
inline const std::string& DataSource::inline_string() const {
  // @@protoc_insertion_point(field_get:envoy.config.core.v3.DataSource.inline_string)
  if (has_inline_string()) {
    return specifier_.inline_string_.GetNoArena();
  }
  return *&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void DataSource::set_inline_string(const std::string& value) {
  // @@protoc_insertion_point(field_set:envoy.config.core.v3.DataSource.inline_string)
  if (!has_inline_string()) {
    clear_specifier();
    set_has_inline_string();
    specifier_.inline_string_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  specifier_.inline_string_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:envoy.config.core.v3.DataSource.inline_string)
}
inline void DataSource::set_inline_string(std::string&& value) {
  // @@protoc_insertion_point(field_set:envoy.config.core.v3.DataSource.inline_string)
  if (!has_inline_string()) {
    clear_specifier();
    set_has_inline_string();
    specifier_.inline_string_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  specifier_.inline_string_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:envoy.config.core.v3.DataSource.inline_string)
}
inline void DataSource::set_inline_string(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  if (!has_inline_string()) {
    clear_specifier();
    set_has_inline_string();
    specifier_.inline_string_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  specifier_.inline_string_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:envoy.config.core.v3.DataSource.inline_string)
}
inline void DataSource::set_inline_string(const char* value, size_t size) {
  if (!has_inline_string()) {
    clear_specifier();
    set_has_inline_string();
    specifier_.inline_string_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  specifier_.inline_string_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:envoy.config.core.v3.DataSource.inline_string)
}
inline std::string* DataSource::mutable_inline_string() {
  if (!has_inline_string()) {
    clear_specifier();
    set_has_inline_string();
    specifier_.inline_string_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:envoy.config.core.v3.DataSource.inline_string)
  return specifier_.inline_string_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DataSource::release_inline_string() {
  // @@protoc_insertion_point(field_release:envoy.config.core.v3.DataSource.inline_string)
  if (has_inline_string()) {
    clear_has_specifier();
    return specifier_.inline_string_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  } else {
    return nullptr;
  }
}
inline void DataSource::set_allocated_inline_string(std::string* inline_string) {
  if (has_specifier()) {
    clear_specifier();
  }
  if (inline_string != nullptr) {
    set_has_inline_string();
    specifier_.inline_string_.UnsafeSetDefault(inline_string);
  }
  // @@protoc_insertion_point(field_set_allocated:envoy.config.core.v3.DataSource.inline_string)
}

inline bool DataSource::has_specifier() const {
  return specifier_case() != SPECIFIER_NOT_SET;
}
inline void DataSource::clear_has_specifier() {
  _oneof_case_[0] = SPECIFIER_NOT_SET;
}
inline DataSource::SpecifierCase DataSource::specifier_case() const {
  return DataSource::SpecifierCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// RetryPolicy

// .envoy.config.core.v3.BackoffStrategy retry_back_off = 1;
inline bool RetryPolicy::has_retry_back_off() const {
  return this != internal_default_instance() && retry_back_off_ != nullptr;
}
inline const ::envoy::config::core::v3::BackoffStrategy& RetryPolicy::retry_back_off() const {
  const ::envoy::config::core::v3::BackoffStrategy* p = retry_back_off_;
  // @@protoc_insertion_point(field_get:envoy.config.core.v3.RetryPolicy.retry_back_off)
  return p != nullptr ? *p : *reinterpret_cast<const ::envoy::config::core::v3::BackoffStrategy*>(
      &::envoy::config::core::v3::_BackoffStrategy_default_instance_);
}
inline ::envoy::config::core::v3::BackoffStrategy* RetryPolicy::release_retry_back_off() {
  // @@protoc_insertion_point(field_release:envoy.config.core.v3.RetryPolicy.retry_back_off)
  
  ::envoy::config::core::v3::BackoffStrategy* temp = retry_back_off_;
  retry_back_off_ = nullptr;
  return temp;
}
inline ::envoy::config::core::v3::BackoffStrategy* RetryPolicy::mutable_retry_back_off() {
  
  if (retry_back_off_ == nullptr) {
    auto* p = CreateMaybeMessage<::envoy::config::core::v3::BackoffStrategy>(GetArenaNoVirtual());
    retry_back_off_ = p;
  }
  // @@protoc_insertion_point(field_mutable:envoy.config.core.v3.RetryPolicy.retry_back_off)
  return retry_back_off_;
}
inline void RetryPolicy::set_allocated_retry_back_off(::envoy::config::core::v3::BackoffStrategy* retry_back_off) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(retry_back_off_);
  }
  if (retry_back_off) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      retry_back_off = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, retry_back_off, submessage_arena);
    }
    
  } else {
    
  }
  retry_back_off_ = retry_back_off;
  // @@protoc_insertion_point(field_set_allocated:envoy.config.core.v3.RetryPolicy.retry_back_off)
}

// .google.protobuf.UInt32Value num_retries = 2;
inline bool RetryPolicy::has_num_retries() const {
  return this != internal_default_instance() && num_retries_ != nullptr;
}
inline const PROTOBUF_NAMESPACE_ID::UInt32Value& RetryPolicy::num_retries() const {
  const PROTOBUF_NAMESPACE_ID::UInt32Value* p = num_retries_;
  // @@protoc_insertion_point(field_get:envoy.config.core.v3.RetryPolicy.num_retries)
  return p != nullptr ? *p : *reinterpret_cast<const PROTOBUF_NAMESPACE_ID::UInt32Value*>(
      &PROTOBUF_NAMESPACE_ID::_UInt32Value_default_instance_);
}
inline PROTOBUF_NAMESPACE_ID::UInt32Value* RetryPolicy::release_num_retries() {
  // @@protoc_insertion_point(field_release:envoy.config.core.v3.RetryPolicy.num_retries)
  
  PROTOBUF_NAMESPACE_ID::UInt32Value* temp = num_retries_;
  num_retries_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::UInt32Value* RetryPolicy::mutable_num_retries() {
  
  if (num_retries_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::UInt32Value>(GetArenaNoVirtual());
    num_retries_ = p;
  }
  // @@protoc_insertion_point(field_mutable:envoy.config.core.v3.RetryPolicy.num_retries)
  return num_retries_;
}
inline void RetryPolicy::set_allocated_num_retries(PROTOBUF_NAMESPACE_ID::UInt32Value* num_retries) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(num_retries_);
  }
  if (num_retries) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(num_retries)->GetArena();
    if (message_arena != submessage_arena) {
      num_retries = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, num_retries, submessage_arena);
    }
    
  } else {
    
  }
  num_retries_ = num_retries;
  // @@protoc_insertion_point(field_set_allocated:envoy.config.core.v3.RetryPolicy.num_retries)
}

// -------------------------------------------------------------------

// RemoteDataSource

// .envoy.config.core.v3.HttpUri http_uri = 1 [(.validate.rules) = {
inline bool RemoteDataSource::has_http_uri() const {
  return this != internal_default_instance() && http_uri_ != nullptr;
}
inline const ::envoy::config::core::v3::HttpUri& RemoteDataSource::http_uri() const {
  const ::envoy::config::core::v3::HttpUri* p = http_uri_;
  // @@protoc_insertion_point(field_get:envoy.config.core.v3.RemoteDataSource.http_uri)
  return p != nullptr ? *p : *reinterpret_cast<const ::envoy::config::core::v3::HttpUri*>(
      &::envoy::config::core::v3::_HttpUri_default_instance_);
}
inline ::envoy::config::core::v3::HttpUri* RemoteDataSource::release_http_uri() {
  // @@protoc_insertion_point(field_release:envoy.config.core.v3.RemoteDataSource.http_uri)
  
  ::envoy::config::core::v3::HttpUri* temp = http_uri_;
  http_uri_ = nullptr;
  return temp;
}
inline ::envoy::config::core::v3::HttpUri* RemoteDataSource::mutable_http_uri() {
  
  if (http_uri_ == nullptr) {
    auto* p = CreateMaybeMessage<::envoy::config::core::v3::HttpUri>(GetArenaNoVirtual());
    http_uri_ = p;
  }
  // @@protoc_insertion_point(field_mutable:envoy.config.core.v3.RemoteDataSource.http_uri)
  return http_uri_;
}
inline void RemoteDataSource::set_allocated_http_uri(::envoy::config::core::v3::HttpUri* http_uri) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(http_uri_);
  }
  if (http_uri) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      http_uri = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, http_uri, submessage_arena);
    }
    
  } else {
    
  }
  http_uri_ = http_uri;
  // @@protoc_insertion_point(field_set_allocated:envoy.config.core.v3.RemoteDataSource.http_uri)
}

// string sha256 = 2 [(.validate.rules) = {
inline void RemoteDataSource::clear_sha256() {
  sha256_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& RemoteDataSource::sha256() const {
  // @@protoc_insertion_point(field_get:envoy.config.core.v3.RemoteDataSource.sha256)
  return sha256_.GetNoArena();
}
inline void RemoteDataSource::set_sha256(const std::string& value) {
  
  sha256_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:envoy.config.core.v3.RemoteDataSource.sha256)
}
inline void RemoteDataSource::set_sha256(std::string&& value) {
  
  sha256_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:envoy.config.core.v3.RemoteDataSource.sha256)
}
inline void RemoteDataSource::set_sha256(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  sha256_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:envoy.config.core.v3.RemoteDataSource.sha256)
}
inline void RemoteDataSource::set_sha256(const char* value, size_t size) {
  
  sha256_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:envoy.config.core.v3.RemoteDataSource.sha256)
}
inline std::string* RemoteDataSource::mutable_sha256() {
  
  // @@protoc_insertion_point(field_mutable:envoy.config.core.v3.RemoteDataSource.sha256)
  return sha256_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* RemoteDataSource::release_sha256() {
  // @@protoc_insertion_point(field_release:envoy.config.core.v3.RemoteDataSource.sha256)
  
  return sha256_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void RemoteDataSource::set_allocated_sha256(std::string* sha256) {
  if (sha256 != nullptr) {
    
  } else {
    
  }
  sha256_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sha256);
  // @@protoc_insertion_point(field_set_allocated:envoy.config.core.v3.RemoteDataSource.sha256)
}

// .envoy.config.core.v3.RetryPolicy retry_policy = 3;
inline bool RemoteDataSource::has_retry_policy() const {
  return this != internal_default_instance() && retry_policy_ != nullptr;
}
inline void RemoteDataSource::clear_retry_policy() {
  if (GetArenaNoVirtual() == nullptr && retry_policy_ != nullptr) {
    delete retry_policy_;
  }
  retry_policy_ = nullptr;
}
inline const ::envoy::config::core::v3::RetryPolicy& RemoteDataSource::retry_policy() const {
  const ::envoy::config::core::v3::RetryPolicy* p = retry_policy_;
  // @@protoc_insertion_point(field_get:envoy.config.core.v3.RemoteDataSource.retry_policy)
  return p != nullptr ? *p : *reinterpret_cast<const ::envoy::config::core::v3::RetryPolicy*>(
      &::envoy::config::core::v3::_RetryPolicy_default_instance_);
}
inline ::envoy::config::core::v3::RetryPolicy* RemoteDataSource::release_retry_policy() {
  // @@protoc_insertion_point(field_release:envoy.config.core.v3.RemoteDataSource.retry_policy)
  
  ::envoy::config::core::v3::RetryPolicy* temp = retry_policy_;
  retry_policy_ = nullptr;
  return temp;
}
inline ::envoy::config::core::v3::RetryPolicy* RemoteDataSource::mutable_retry_policy() {
  
  if (retry_policy_ == nullptr) {
    auto* p = CreateMaybeMessage<::envoy::config::core::v3::RetryPolicy>(GetArenaNoVirtual());
    retry_policy_ = p;
  }
  // @@protoc_insertion_point(field_mutable:envoy.config.core.v3.RemoteDataSource.retry_policy)
  return retry_policy_;
}
inline void RemoteDataSource::set_allocated_retry_policy(::envoy::config::core::v3::RetryPolicy* retry_policy) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete retry_policy_;
  }
  if (retry_policy) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      retry_policy = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, retry_policy, submessage_arena);
    }
    
  } else {
    
  }
  retry_policy_ = retry_policy;
  // @@protoc_insertion_point(field_set_allocated:envoy.config.core.v3.RemoteDataSource.retry_policy)
}

// -------------------------------------------------------------------

// AsyncDataSource

// .envoy.config.core.v3.DataSource local = 1;
inline bool AsyncDataSource::has_local() const {
  return specifier_case() == kLocal;
}
inline void AsyncDataSource::set_has_local() {
  _oneof_case_[0] = kLocal;
}
inline void AsyncDataSource::clear_local() {
  if (has_local()) {
    delete specifier_.local_;
    clear_has_specifier();
  }
}
inline ::envoy::config::core::v3::DataSource* AsyncDataSource::release_local() {
  // @@protoc_insertion_point(field_release:envoy.config.core.v3.AsyncDataSource.local)
  if (has_local()) {
    clear_has_specifier();
      ::envoy::config::core::v3::DataSource* temp = specifier_.local_;
    specifier_.local_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::envoy::config::core::v3::DataSource& AsyncDataSource::local() const {
  // @@protoc_insertion_point(field_get:envoy.config.core.v3.AsyncDataSource.local)
  return has_local()
      ? *specifier_.local_
      : *reinterpret_cast< ::envoy::config::core::v3::DataSource*>(&::envoy::config::core::v3::_DataSource_default_instance_);
}
inline ::envoy::config::core::v3::DataSource* AsyncDataSource::mutable_local() {
  if (!has_local()) {
    clear_specifier();
    set_has_local();
    specifier_.local_ = CreateMaybeMessage< ::envoy::config::core::v3::DataSource >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:envoy.config.core.v3.AsyncDataSource.local)
  return specifier_.local_;
}

// .envoy.config.core.v3.RemoteDataSource remote = 2;
inline bool AsyncDataSource::has_remote() const {
  return specifier_case() == kRemote;
}
inline void AsyncDataSource::set_has_remote() {
  _oneof_case_[0] = kRemote;
}
inline void AsyncDataSource::clear_remote() {
  if (has_remote()) {
    delete specifier_.remote_;
    clear_has_specifier();
  }
}
inline ::envoy::config::core::v3::RemoteDataSource* AsyncDataSource::release_remote() {
  // @@protoc_insertion_point(field_release:envoy.config.core.v3.AsyncDataSource.remote)
  if (has_remote()) {
    clear_has_specifier();
      ::envoy::config::core::v3::RemoteDataSource* temp = specifier_.remote_;
    specifier_.remote_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::envoy::config::core::v3::RemoteDataSource& AsyncDataSource::remote() const {
  // @@protoc_insertion_point(field_get:envoy.config.core.v3.AsyncDataSource.remote)
  return has_remote()
      ? *specifier_.remote_
      : *reinterpret_cast< ::envoy::config::core::v3::RemoteDataSource*>(&::envoy::config::core::v3::_RemoteDataSource_default_instance_);
}
inline ::envoy::config::core::v3::RemoteDataSource* AsyncDataSource::mutable_remote() {
  if (!has_remote()) {
    clear_specifier();
    set_has_remote();
    specifier_.remote_ = CreateMaybeMessage< ::envoy::config::core::v3::RemoteDataSource >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:envoy.config.core.v3.AsyncDataSource.remote)
  return specifier_.remote_;
}

inline bool AsyncDataSource::has_specifier() const {
  return specifier_case() != SPECIFIER_NOT_SET;
}
inline void AsyncDataSource::clear_has_specifier() {
  _oneof_case_[0] = SPECIFIER_NOT_SET;
}
inline AsyncDataSource::SpecifierCase AsyncDataSource::specifier_case() const {
  return AsyncDataSource::SpecifierCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// TransportSocket

// string name = 1 [(.validate.rules) = {
inline void TransportSocket::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& TransportSocket::name() const {
  // @@protoc_insertion_point(field_get:envoy.config.core.v3.TransportSocket.name)
  return name_.GetNoArena();
}
inline void TransportSocket::set_name(const std::string& value) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:envoy.config.core.v3.TransportSocket.name)
}
inline void TransportSocket::set_name(std::string&& value) {
  
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:envoy.config.core.v3.TransportSocket.name)
}
inline void TransportSocket::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:envoy.config.core.v3.TransportSocket.name)
}
inline void TransportSocket::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:envoy.config.core.v3.TransportSocket.name)
}
inline std::string* TransportSocket::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:envoy.config.core.v3.TransportSocket.name)
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* TransportSocket::release_name() {
  // @@protoc_insertion_point(field_release:envoy.config.core.v3.TransportSocket.name)
  
  return name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void TransportSocket::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:envoy.config.core.v3.TransportSocket.name)
}

// .google.protobuf.Any typed_config = 3;
inline bool TransportSocket::has_typed_config() const {
  return config_type_case() == kTypedConfig;
}
inline void TransportSocket::set_has_typed_config() {
  _oneof_case_[0] = kTypedConfig;
}
inline PROTOBUF_NAMESPACE_ID::Any* TransportSocket::release_typed_config() {
  // @@protoc_insertion_point(field_release:envoy.config.core.v3.TransportSocket.typed_config)
  if (has_typed_config()) {
    clear_has_config_type();
      PROTOBUF_NAMESPACE_ID::Any* temp = config_type_.typed_config_;
    config_type_.typed_config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const PROTOBUF_NAMESPACE_ID::Any& TransportSocket::typed_config() const {
  // @@protoc_insertion_point(field_get:envoy.config.core.v3.TransportSocket.typed_config)
  return has_typed_config()
      ? *config_type_.typed_config_
      : *reinterpret_cast< PROTOBUF_NAMESPACE_ID::Any*>(&PROTOBUF_NAMESPACE_ID::_Any_default_instance_);
}
inline PROTOBUF_NAMESPACE_ID::Any* TransportSocket::mutable_typed_config() {
  if (!has_typed_config()) {
    clear_config_type();
    set_has_typed_config();
    config_type_.typed_config_ = CreateMaybeMessage< PROTOBUF_NAMESPACE_ID::Any >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:envoy.config.core.v3.TransportSocket.typed_config)
  return config_type_.typed_config_;
}

inline bool TransportSocket::has_config_type() const {
  return config_type_case() != CONFIG_TYPE_NOT_SET;
}
inline void TransportSocket::clear_has_config_type() {
  _oneof_case_[0] = CONFIG_TYPE_NOT_SET;
}
inline TransportSocket::ConfigTypeCase TransportSocket::config_type_case() const {
  return TransportSocket::ConfigTypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// RuntimeFractionalPercent

// .envoy.type.v3.FractionalPercent default_value = 1 [(.validate.rules) = {
inline bool RuntimeFractionalPercent::has_default_value() const {
  return this != internal_default_instance() && default_value_ != nullptr;
}
inline const ::envoy::type::v3::FractionalPercent& RuntimeFractionalPercent::default_value() const {
  const ::envoy::type::v3::FractionalPercent* p = default_value_;
  // @@protoc_insertion_point(field_get:envoy.config.core.v3.RuntimeFractionalPercent.default_value)
  return p != nullptr ? *p : *reinterpret_cast<const ::envoy::type::v3::FractionalPercent*>(
      &::envoy::type::v3::_FractionalPercent_default_instance_);
}
inline ::envoy::type::v3::FractionalPercent* RuntimeFractionalPercent::release_default_value() {
  // @@protoc_insertion_point(field_release:envoy.config.core.v3.RuntimeFractionalPercent.default_value)
  
  ::envoy::type::v3::FractionalPercent* temp = default_value_;
  default_value_ = nullptr;
  return temp;
}
inline ::envoy::type::v3::FractionalPercent* RuntimeFractionalPercent::mutable_default_value() {
  
  if (default_value_ == nullptr) {
    auto* p = CreateMaybeMessage<::envoy::type::v3::FractionalPercent>(GetArenaNoVirtual());
    default_value_ = p;
  }
  // @@protoc_insertion_point(field_mutable:envoy.config.core.v3.RuntimeFractionalPercent.default_value)
  return default_value_;
}
inline void RuntimeFractionalPercent::set_allocated_default_value(::envoy::type::v3::FractionalPercent* default_value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(default_value_);
  }
  if (default_value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      default_value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, default_value, submessage_arena);
    }
    
  } else {
    
  }
  default_value_ = default_value;
  // @@protoc_insertion_point(field_set_allocated:envoy.config.core.v3.RuntimeFractionalPercent.default_value)
}

// string runtime_key = 2;
inline void RuntimeFractionalPercent::clear_runtime_key() {
  runtime_key_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& RuntimeFractionalPercent::runtime_key() const {
  // @@protoc_insertion_point(field_get:envoy.config.core.v3.RuntimeFractionalPercent.runtime_key)
  return runtime_key_.GetNoArena();
}
inline void RuntimeFractionalPercent::set_runtime_key(const std::string& value) {
  
  runtime_key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:envoy.config.core.v3.RuntimeFractionalPercent.runtime_key)
}
inline void RuntimeFractionalPercent::set_runtime_key(std::string&& value) {
  
  runtime_key_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:envoy.config.core.v3.RuntimeFractionalPercent.runtime_key)
}
inline void RuntimeFractionalPercent::set_runtime_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  runtime_key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:envoy.config.core.v3.RuntimeFractionalPercent.runtime_key)
}
inline void RuntimeFractionalPercent::set_runtime_key(const char* value, size_t size) {
  
  runtime_key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:envoy.config.core.v3.RuntimeFractionalPercent.runtime_key)
}
inline std::string* RuntimeFractionalPercent::mutable_runtime_key() {
  
  // @@protoc_insertion_point(field_mutable:envoy.config.core.v3.RuntimeFractionalPercent.runtime_key)
  return runtime_key_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* RuntimeFractionalPercent::release_runtime_key() {
  // @@protoc_insertion_point(field_release:envoy.config.core.v3.RuntimeFractionalPercent.runtime_key)
  
  return runtime_key_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void RuntimeFractionalPercent::set_allocated_runtime_key(std::string* runtime_key) {
  if (runtime_key != nullptr) {
    
  } else {
    
  }
  runtime_key_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), runtime_key);
  // @@protoc_insertion_point(field_set_allocated:envoy.config.core.v3.RuntimeFractionalPercent.runtime_key)
}

// -------------------------------------------------------------------

// ControlPlane

// string identifier = 1;
inline void ControlPlane::clear_identifier() {
  identifier_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& ControlPlane::identifier() const {
  // @@protoc_insertion_point(field_get:envoy.config.core.v3.ControlPlane.identifier)
  return identifier_.GetNoArena();
}
inline void ControlPlane::set_identifier(const std::string& value) {
  
  identifier_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:envoy.config.core.v3.ControlPlane.identifier)
}
inline void ControlPlane::set_identifier(std::string&& value) {
  
  identifier_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:envoy.config.core.v3.ControlPlane.identifier)
}
inline void ControlPlane::set_identifier(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  identifier_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:envoy.config.core.v3.ControlPlane.identifier)
}
inline void ControlPlane::set_identifier(const char* value, size_t size) {
  
  identifier_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:envoy.config.core.v3.ControlPlane.identifier)
}
inline std::string* ControlPlane::mutable_identifier() {
  
  // @@protoc_insertion_point(field_mutable:envoy.config.core.v3.ControlPlane.identifier)
  return identifier_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ControlPlane::release_identifier() {
  // @@protoc_insertion_point(field_release:envoy.config.core.v3.ControlPlane.identifier)
  
  return identifier_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ControlPlane::set_allocated_identifier(std::string* identifier) {
  if (identifier != nullptr) {
    
  } else {
    
  }
  identifier_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), identifier);
  // @@protoc_insertion_point(field_set_allocated:envoy.config.core.v3.ControlPlane.identifier)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v3
}  // namespace core
}  // namespace config
}  // namespace envoy

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::envoy::config::core::v3::RoutingPriority> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::envoy::config::core::v3::RoutingPriority>() {
  return ::envoy::config::core::v3::RoutingPriority_descriptor();
}
template <> struct is_proto_enum< ::envoy::config::core::v3::RequestMethod> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::envoy::config::core::v3::RequestMethod>() {
  return ::envoy::config::core::v3::RequestMethod_descriptor();
}
template <> struct is_proto_enum< ::envoy::config::core::v3::TrafficDirection> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::envoy::config::core::v3::TrafficDirection>() {
  return ::envoy::config::core::v3::TrafficDirection_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_envoy_2fconfig_2fcore_2fv3_2fbase_2eproto
